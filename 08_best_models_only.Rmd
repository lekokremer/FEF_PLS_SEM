# Best performing PLS-SEM FEF models

```{r pkgs, include=FALSE}
# pkgTest is a helper function to load packages and install packages only when they are not installed yet.
pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

#"rstan", "devtools", "tidyverse",  "ggpmisc", "reshape2", 
neededPackages <- c('seminr', 'tidyr', 'dplyr', 'lubridate', 'ggplot2')

for (package in neededPackages){pkgTest(package)}

source('test_pls_models_function.R')
```


```{r import_data, include = FALSE}
# IMPORT PARAFAC results
file <- normalizePath(file.path(getwd(), "datafiles/df_loadings.csv"))
parafac <- read.csv(file, header = TRUE, sep = ",", quote = "\"",
         dec = ".", fill = TRUE) %>%
  # Widen the parafac dataframe
  #pivot_wider(names_from = Component, values_from = Proportion) %>%
  # Extract the sample no. to match other dataframe
  mutate(ID = substr(Sample, nchar(Sample) - 2, nchar(Sample)))
```

```{r import_data2, include = FALSE}

# Move up one directory from the current working directory
file <- normalizePath(file.path(getwd(), "/datafiles/fluoro_topo_melt_PARAFAC.csv"))

# Read the CSV file
sample_vege_fluro_topo <- read.csv(file) 
```

```{r Merge_dataframes, include=FALSE}
# Merge vegetation, topography and fluoro data with PARAFAC results. 
merged_df <- merge(sample_vege_fluro_topo, parafac, by='ID')%>%
  mutate(across(c(watershed, reach, position, TYPE), as.factor))%>%
  mutate(datetime = ymd(date))

merged_df <- merged_df %>%
  mutate(
    percent_Beetle.kill = replace_na(percent_Beetle.kill, 0),
    percent_Old.Forest = replace_na(percent_Old.Forest, 0),
    percent_cut.regenerating = replace_na(percent_cut.regenerating, 0),
    percent_Tundra = replace_na(percent_Tundra, 0),
    percent_Meadows = replace_na(percent_Meadows, 0)
  )
```

```{r Formatting_subsetting, include=FALSE}
# Generate a discharge column that is normalized by the area of the respective watershed.
merged_df<- merged_df%>%
  mutate(Qm3_s = replace_na(Qm3_s, 0.005)) %>%
  dplyr::select(-c(PARAF_comp_1.x, PARAF_comp_2.x, PARAF_comp_3.x, total_loadings.x, Sample.x, relative_load_comp_1.x, relative_load_comp_2.x, relative_load_comp_3.x)) %>% #remove duplicate columns
  rename_with(~ gsub("\\.y$", "", .), ends_with(".y")) #removes .y from names 

# Generate a discharge column that is normalized by the area of the respective watershed.
merged_df<- merged_df%>%
  mutate(Qm3_s = replace_na(Qm3_s, 0.005))

merged_df$discharge_m2 <- merged_df$Qm3_s/merged_df$area_m
merged_df$Input.mm_m2 <- merged_df$Input.mm/merged_df$area_m
merged_df$snowpack_m2 <- merged_df$snowpack_3day_avg/merged_df$area_m

# Transform aspect from degrees to radians
merged_df$aspect_mean_rad <- merged_df$aspect_mean*pi/180
```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

## Model 1 (AUTOMATED): High flows - HUMIC

```{r filtering_08.1, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>%
  filter(format(datetime, "%m-%d") >= "05-01" & format(datetime, "%m-%d") <= "07-31")

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```
********ADDED 20Jan2025 Automation with same filtering********

### Initialize model_df with the same number of rows as filtered_df

```{r}
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean', 'area_km', "elevabovestreams_mean", "elevabovestreams_median",  "aspect_mean_rad"),
  hydro = c("snowpack_3day_avg", "discharge_m2"),
  landcover = c("percent_Beetle.kill", "percent_Meadows","percent_Old.Forest","percent_cut.regenerating",
"percent_Tundra" ,"ndvi_raster_mean"),
  doc = c("relative_load_comp_1", "relative_load_comp_2", "norm_PARAF_c1", "norm_PARAF_c2", "peak_T_275.340", "Fluorescence_Index", "SUVA254", "peak_ratioAT", "peak_ratioCT"),
  nutr = c('NO3_mg.l', "na_mg.l", "nh4_mg.l", "K_mg.l",  "Mg_mg.l", "Ca_mg.l", "F_mg.l", "Cl_mg.l", "SO4_mg.l")
)
```

### Run the function written in .R script
```{r, echo=FALSE}
set.seed(123)  # For reproducibility
#org_runs <- pls_models_nutrients(filtered_df, indicators, n_iter = 20000)
# Filter out NULL entries from the org_runs list
#org_runs_no_nan <- org_runs[!sapply(org_runs, is.null)]

# Save the list
#saveRDS(org_runs_no_nan, file = "all_response_all_flow_20000.rds")

# Load the list
imp_results <- readRDS("all_response_all_flow_20000.rds")
```

#20000 run winner:
sorted_results[[1]]$summary$paths["R^2", "DOC"]
[1] 0.8670748
> sorted_results[[1]]$sampled_indicators
$topo
[1] "elevabovestreams_median" "elevabovestreams_mean"  

$hydro
[1] "discharge_m2"

$landcover
[1] "percent_Tundra"

$doc
[1] "Fluorescence_Index"

$nutr
[1] "Mg_mg.l"
```{r, echo=FALSE}
# Extract the R^2 for DOC for each non-NULL result
r2_humic_values <- sapply(imp_results, function(res) {
  res$summary$paths["R^2", "DOC"]
})
print(r2_humic_values)
```


```{r, echo=FALSE}
# Sort indices based on the extracted R^2 values
sorted_indices <- order(r2_humic_values, decreasing = TRUE)

# Sort the non-NULL results by the sorted indices
sorted_results <- imp_results[sorted_indices]

# Sorted results now contains the summaries ordered by R^2 for DOC
sorted_results[[1]]$summary$paths["R^2", "DOC"]
sorted_results[[1]]$sampled_indicators

```

Or we can use this to find the highest performing model where some value is specified for the 'DOC' response

```{r, echo=FALSE}
# Filter results for the specific DOC component 'relative_load_comp_3'
specific_DOC_results <- Filter(function(res) {
  'relative_load_comp_1' %in% res$sampled_indicators$doc
}, sorted_results)

# If there are multiple models, select the one with the highest R^2 for DOC
if (length(specific_DOC_results) > 0) {
  best_model <- specific_DOC_results[[1]]  # Select the first model (best-performing)
  
  # Display the R^2 value for DOC
  best_r2_DOC <- best_model$summary$paths["R^2", "DOC"]
  cat("Best R^2 for DOC:", best_r2_DOC, "\n")
  
  # Display sampled indicators for this best model
  cat("Sampled indicators for best model:\n")
  print(best_model$sampled_indicators)
} else {
  cat("No models found with DOC as 'relative_load_comp_1'\n")
}
```
Best R^2 for DOC: 0.7013748 
Sampled indicators for best model:
$topo
[1] "aspect_mean_rad"

$hydro
[1] "snowpack_3day_avg"

$landcover
[1] "percent_Tundra"

$doc
[1] "relative_load_comp_1"

$nutr
[1] "SO4_mg.l"

### Visualizing all selected results (r2 of DOC >0.4)
#### indicator frequency

```{r, echo=FALSE}
# Extract the associated latent variable with each indicator:
indicator_list <- lapply(sorted_results, function(result) {
  # Iterate over each category in sampled_indicators
  do.call(rbind, lapply(names(result$sampled_indicators), function(category) {
    # Create a data frame for each category and its indicators
    data.frame(
      Indicator = result$sampled_indicators[[category]],
      Category = category)
    }))
  })

# Combine all data frames into a single data frame
indicator_df <- do.call(rbind, indicator_list)

# Create the frequency table
indicator_counts <- as.data.frame(table(indicator_df$Indicator))
colnames(indicator_counts) <- c("Indicator", "Frequency")

# Merge the Category information from indicator_df
indicator_counts <- merge(indicator_counts, indicator_df[, c("Indicator", "Category")], by = "Indicator", all.x = TRUE)

# Ensure unique rows (to avoid duplication during merge)
indicator_counts <- indicator_counts[!duplicated(indicator_counts), ]

# Step 4: Visualize the results with a bar plot (using ggplot2)
# Create the bar plot with colors by category
ggplot(indicator_counts, aes(x = reorder(Indicator, Frequency), y = Frequency, fill = Category)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_manual(
    values = c("topo" = "#e31a1c", "hydro" = "#1f78b4", 
               "landcover" = "#33a02c", "doc" = "#ff7f00", 
               "nutr" = "#6a3d9a")
  ) +
  labs(
    title = "Frequency of Sampled Indicators by Category",
    x = "Indicator",
    y = "Frequency",
    fill = "Category"
  ) +
  theme_minimal()

```

#### R2 distribution

```{r, echo=FALSE}
# Extract R^2 values for DOC
r_squared_values <- sapply(sorted_results, function(result) {
  if (!is.null(result$summary$paths)) {
    result$summary$paths["R^2", "DOC"]
  } else {
    NA  # Return NA if paths is missing
  }
}, USE.NAMES = FALSE)

# Remove NA values
r_squared_values <- na.omit(r_squared_values)

# Step 3: Visualize the distribution
# Histogram
ggplot(data.frame(R2 = r_squared_values), aes(x = R2)) +
  geom_histogram(binwidth = 0.05, fill = "#ff7f00", color = "black") +
  labs(
    title = "Distribution of R^2 Values for DOC",
    x = "R^2 Value",
    y = "Frequency"
  ) +
  theme_minimal()
```

```{r, echo=FALSE}
# Function to create a dataframe with iteration, indicator, category, and R2 columns
generate_dataframe_with_R2 <- function(sorted_results) {
  do.call(rbind, lapply(seq_along(sorted_results), function(i) {
    iteration <- rep(i, length(unlist(sorted_results[[i]]$sampled_indicators, use.names = FALSE)))
    indicators <- unlist(sorted_results[[i]]$sampled_indicators, use.names = FALSE)
    categories <- rep(names(sorted_results[[i]]$sampled_indicators), lengths(sorted_results[[i]]$sampled_indicators))
    R2_value <- rep(sorted_results[[i]]$summary$paths["R^2", "DOC"], length(indicators))
    data.frame(Iteration = iteration, Indicator = indicators, Category = categories, R2 = R2_value)
  }))
}

# Example usage
indicator_list <- generate_dataframe_with_R2(sorted_results)

```

#### Combine these two ideas: Create the dataframe

```{r, echo=FALSE}
# Apply the same color scheme for categories
ggplot(indicator_list, aes(x = Indicator, y = R2, fill = Category)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.5) +
  scale_fill_manual(values = c(
    "topo" = "#e31a1c",   # Example color for topo
    "hydro" = "#1f78b4",  # Example color for hydro
    "landcover" = "#33a02c", # Example color for landcover
    "doc" = "#ff7f00",    # Example color for doc
    "nutr" = "#6a3d9a"   # Example color for nutr (added here)
  )) + 
  labs(
    title = "Distribution of R^2 Values by Indicator",
    x = "Indicator",
    y = "R^2 Value"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

### Visualizing specific DOC results (r2 of DOC >0.4)
#### indicator frequency

```{r, echo=FALSE}
# Extract the associated latent variable with each indicator:
indicator_list <- lapply(specific_DOC_results, function(result) {
  # Iterate over each category in sampled_indicators
  do.call(rbind, lapply(names(result$sampled_indicators), function(category) {
    # Create a data frame for each category and its indicators
    data.frame(
      Indicator = result$sampled_indicators[[category]],
      Category = category)
    }))
  })

# Combine all data frames into a single data frame
indicator_df <- do.call(rbind, indicator_list)

# Create the frequency table
indicator_counts <- as.data.frame(table(indicator_df$Indicator))
colnames(indicator_counts) <- c("Indicator", "Frequency")

# Merge the Category information from indicator_df
indicator_counts <- merge(indicator_counts, indicator_df[, c("Indicator", "Category")], by = "Indicator", all.x = TRUE)

# Ensure unique rows (to avoid duplication during merge)
indicator_counts <- indicator_counts[!duplicated(indicator_counts), ]

# Step 4: Visualize the results with a bar plot (using ggplot2)
# Create the bar plot with colors by category
ggplot(indicator_counts, aes(x = reorder(Indicator, Frequency), y = Frequency, fill = Category)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_manual(
    values = c("topo" = "#e31a1c", "hydro" = "#1f78b4", 
               "landcover" = "#33a02c", "doc" = "#ff7f00", 
               "nutr" = "#6a3d9a")
  ) +
  labs(
    title = "Frequency of Sampled Indicators by Category",
    x = "Indicator",
    y = "Frequency",
    fill = "Category"
  ) +
  theme_minimal()

```

#### R2 distribution


```{r, echo=FALSE}
# Function to create a dataframe with iteration, indicator, category, and R2 columns
generate_dataframe_with_R2 <- function(specific_DOC_results) {
  do.call(rbind, lapply(seq_along(specific_DOC_results), function(i) {
    iteration <- rep(i, length(unlist(specific_DOC_results[[i]]$sampled_indicators, use.names = FALSE)))
    indicators <- unlist(specific_DOC_results[[i]]$sampled_indicators, use.names = FALSE)
    categories <- rep(names(specific_DOC_results[[i]]$sampled_indicators), lengths(specific_DOC_results[[i]]$sampled_indicators))
    R2_value <- rep(specific_DOC_results[[i]]$summary$paths["R^2", "DOC"], length(indicators))
    data.frame(Iteration = iteration, Indicator = indicators, Category = categories, R2 = R2_value)
  }))
}

# usage
indicator_list <- generate_dataframe_with_R2(specific_DOC_results)
```

#### Combine these two ideas: Create the dataframe

```{r, echo=FALSE}
# Apply the same color scheme for categories
ggplot(indicator_list, aes(x = Indicator, y = R2, fill = Category)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.5) +
  scale_fill_manual(values = c(
    "topo" = "#e31a1c",   # Example color for topo
    "hydro" = "#1f78b4",  # Example color for hydro
    "landcover" = "#33a02c", # Example color for landcover
    "doc" = "#ff7f00",    # Example color for doc
    "nutr" = "#6a3d9a"   # Example color for nutr (added here)
  )) + 
  labs(
    title = "Distribution of R^2 Values by Indicator",
    x = "Indicator",
    y = "R^2 Value"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```





## Model 1 (NOT - AUTOMATED): High flows - HUMIC
For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (total stream n= 91)

**ABOUT THIS MODEL**
- stream samples during peak flows (May 1 - July 31) n=33
- response is HUMIC. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Runoff** <br>
-- log_discharge_m2 <br>
**Landcover:** <br>
-- % of subcatchment pixels with beetle kill and  harvested/regenerating vegetation
**Nutrient:**
-- nitrate [NO3]mg/L in water sample
Usually the dominant form of dissolved N exported from forests via streams(Ryan and Lawrence, 2024). stimulates microbial activity, potentially reducing the fraction on labile carbon in the water column. Microbes can polymerize or oxydize simpler carbon molecules producing humic-like substances that are more recalcitrant (T.C. Balser 2005).
**HUMIC:** <br>
-- "PARAF_comp_1" = total loading of humic component 1. A 'total loading' is a number that tells us how much of a particular compoent is present in a particular sample.<br>  -- "PARAF_comp_2" = total loading of humic component 2. <br> -- "relative_load_comp_1", = the fraction of the total sample absorbance by component 1 <br>
-- "relative_load_comp_2", = the fraction of the total sample absorbance by component 2 <br>
-- "Fluorescence_Index" = fluorescence index (FI) as the ratio of emission intensities at ex=370 em=470: ex370 em520 (cory et al. 2010)<br>

```{r runthemodel_08.1, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  runoff = c("log_discharge_m2"),
  landcover = c( "percent_Tundra", "percent_Old.Forest", "percent_Beetle.kill", "percent_cut.regenerating"),
  humic = c( "relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index", "SUVA254"),
#  Cfix_ions = c("Mg_mg.l", "Ca_mg.l"),
  Cgen_nutr = c('NO3_mg.l') #"peak_C_350.450",
)


# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("RUNOFF",  multi_items("runoff_", 1:1)), #single_item("runoff_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:4)),
#  composite("F_IONS", multi_items("Cfix_ions_", 1:2)),
  composite("HUMIC",  multi_items("humic_", 1:4)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("RUNOFF", "LANDCOVER",  "NUTRIENT")), #"F_IONS",
paths(from = c("LANDCOVER"), to = c("RUNOFF",  "HUMIC", "NUTRIENT")), #"F_IONS",
paths(from = c("RUNOFF"), to = c("HUMIC")),
paths(from =c("NUTRIENT"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 1000,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nHigh flow - Humic")
par(old_par)
```

## Model 2: LOW FLOWS - streams

```{r filtering_08.2, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>% 
  filter((format(datetime, "%m-%d") >= "08-01" & format(datetime, "%m-%d") <= "12-31") | (format(datetime, "%m-%d") >= "01-01" & format(datetime, "%m-%d") <= "04-30"))


filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

**ABOUT THIS MODEL**
- stream samples during low flows (August 1 - April 30) n=58
- response is HUMIC. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Runoff** <br>
-- log_discharge_m2 <br>
**Landcover:** <br>
-- % of subcatchment pixels with beetle kill and  harvested/regenerating vegetation
**Nutrient:**
-- nitrate [NO3]mg/L in water sample
Usually the dominant form of dissolved N exported from forests via streams(Ryan and Lawrence, 2024). stimulates microbial activity, potentially reducing the fraction on labile carbon in the water column. Microbes can polymerize or oxydize simpler carbon molecules producing humic-like substances that are more recalcitrant (T.C. Balser 2005).
**HUMIC:** <br>
-- "PARAF_comp_1" = total loading of humic component 1. A 'total loading' is a number that tells us how much of a particular compoent is present in a particular sample.<br>  -- "PARAF_comp_2" = total loading of humic component 2. <br> -- "relative_load_comp_1", = the fraction of the total sample absorbance by component 1 <br>
-- "relative_load_comp_2", = the fraction of the total sample absorbance by component 2 <br>
-- "Fluorescence_Index" = fluorescence index (FI) as the ratio of emission intensities at ex=370 em=470: ex370 em520 (cory et al. 2010)<br>
-- "SUVA254" = UV absorbance at 254 nm (SUVA254) normalized by DOC concentration: reflects the aromaticity level of DOM


```{r runthemodel_08.2, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  runoff = c("log_discharge_m2"),
  landcover = c( "percent_Tundra", "percent_Old.Forest", "percent_Beetle.kill", "percent_cut.regenerating"),
  humic = c( "PARAF_comp_1", "PARAF_comp_2","relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index"), #, "SUVA254"
#  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_df and add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("RUNOFF",  multi_items("runoff_", 1:1)), #single_item("runoff_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:4)),
 # composite("F_IONS", multi_items("Cfix_ions_", 1:2)),, "SUVA254"
  composite("HUMIC",  multi_items("humic_", 1:5)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("RUNOFF", "LANDCOVER",  "NUTRIENT")),#"F_IONS",
paths(from = c("LANDCOVER"), to = c("RUNOFF",  "HUMIC", "NUTRIENT")),#"F_IONS",
paths(from = c("RUNOFF"), to = c("HUMIC")),
#paths(from =c("F_IONS"), to = c("HUMIC")),
paths(from =c("NUTRIENT"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 10000,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nLow flow - Humic")
par(old_par)
```

```{r}

```

## Model 3: LABILE high flows - streams 

**ABOUT THIS MODEL**
- stream samples during peak flows (May 1 - July 31) n=33
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Runoff** <br>
-- log_discharge_m2 <br>
**Landcover:** <br>
-- % of subcatchment pixels with beetle kill and  harvested/regenerating vegetation
**Nutrient:**
-- nitrate [NO3]mg/L in water sample
**LABILE**
-- "norm_PARAF_c3", "PARAF_comp_3",  "relative_load_comp_3",  "Fluorescence_Index", "SUVA254", "peak_ratioAT", "peak_ratioCT"

```{r filtering_08.3, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>%
  filter(format(datetime, "%m-%d") >= "05-01" & format(datetime, "%m-%d") <= "07-31")

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed
```


```{r runthemodel_08.3, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  runoff = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating", "percent_Old.Forest", "percent_Tundra"),
  labile = c("relative_load_comp_3",  "Fluorescence_Index", "PARAF_comp_1", "PARAF_comp_2","relative_load_comp_1", "relative_load_comp_2"),
  #Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("RUNOFF",  multi_items("runoff_", 1:1)), #single_item("runoff_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  #composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("LABILE",  multi_items("labile_", 1:6)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("RUNOFF", "LANDCOVER",  "NUTRIENT")),#"F_IONS",
paths(from = c("LANDCOVER"), to = c("RUNOFF",  "LABILE", "NUTRIENT")), #"F_IONS",
paths(from = c("RUNOFF"), to = c("LABILE")),
#paths(from =c("F_IONS"), to = c("LABILE")),
paths(from =c("NUTRIENT"), to = c("LABILE"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nHigh flow - LABILE")
par(old_par)
```

## Model 4: LABILE LOW FLOWS - streams

```{r filtering_08.4, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>% 
  filter((format(datetime, "%m-%d") >= "08-01" & format(datetime, "%m-%d") <= "12-31") | (format(datetime, "%m-%d") >= "01-01" & format(datetime, "%m-%d") <= "04-30"))


filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Runoff** <br>
-- log_discharge_m2 <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**LABILE:** <br>

```{r runthemodel_08.4, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
# indicators same as previous model

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_df and add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

# simple_FEF_mm same as above

# Create structural model
# simple_FEF_sm same as above

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 10000,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nLow flow - LABILE")
par(old_par)
```

```{r}

```
