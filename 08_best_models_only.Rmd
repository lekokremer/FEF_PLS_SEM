---
title: "08_best_models_only"
author: "Lauren Kremer"
date: "2024-11-14"
output: html_document
---

# Best performing PLS-SEM FEF models

```{r pkgs, include=FALSE}
# pkgTest is a helper function to load packages and install packages only when they are not installed yet.
pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

#"rstan", "devtools", "tidyverse",  "ggpmisc", "reshape2", 
neededPackages <- c('seminr', 'tidyr', 'dplyr', 'lubridate', 'ggplot2')

for (package in neededPackages){pkgTest(package)}
```


```{r import_data, include = FALSE}
# IMPORT PARAFAC results
file <- normalizePath(file.path(getwd(), "datafiles/df_loadings.csv"))
parafac <- read.csv(file, header = TRUE, sep = ",", quote = "\"",
         dec = ".", fill = TRUE) %>%
  # Widen the parafac dataframe
  #pivot_wider(names_from = Component, values_from = Proportion) %>%
  # Extract the sample no. to match other dataframe
  mutate(ID = substr(Sample, nchar(Sample) - 2, nchar(Sample)))
```

```{r import_data2, include = FALSE}

# Move up one directory from the current working directory
file <- normalizePath(file.path(getwd(), "/datafiles/fluoro_topo_melt_PARAFAC.csv"))

# Read the CSV file
sample_vege_fluro_topo <- read.csv(file) 
```

```{r Merge_dataframes, include=FALSE}
# Merge vegetation, topography and fluoro data with PARAFAC results. 
merged_df <- merge(sample_vege_fluro_topo, parafac, by='ID')%>%
  mutate(across(c(watershed, reach, position, TYPE), as.factor))%>%
  mutate(datetime = ymd(date))

merged_df <- merged_df %>%
  mutate(
    percent_Beetle.kill = replace_na(percent_Beetle.kill, 0),
    percent_Old.Forest = replace_na(percent_Old.Forest, 0),
    percent_cut.regenerating = replace_na(percent_cut.regenerating, 0),
    percent_Tundra = replace_na(percent_Tundra, 0),
    percent_Meadows = replace_na(percent_Meadows, 0)
  )
```

```{r Formatting_subsetting, include=FALSE}
# Generate a discharge column that is normalized by the area of the respective watershed.
merged_df<- merged_df%>%
  mutate(Qm3_s = replace_na(Qm3_s, 0.005)) %>%
  dplyr::select(-c(PARAF_comp_1.x, PARAF_comp_2.x, PARAF_comp_3.x, total_loadings.x, Sample.x, relative_load_comp_1.x, relative_load_comp_2.x, relative_load_comp_3.x)) %>% #remove duplicate columns
  rename_with(~ gsub("\\.y$", "", .), ends_with(".y")) #removes .y from names 

# Generate a discharge column that is normalized by the area of the respective watershed.
merged_df<- merged_df%>%
  mutate(Qm3_s = replace_na(Qm3_s, 0.005))

merged_df$discharge_m2 <- merged_df$Qm3_s/merged_df$area_m
merged_df$Input.mm_m2 <- merged_df$Input.mm/merged_df$area_m
merged_df$snowpack_m2 <- merged_df$snowpack_3day_avg/merged_df$area_m

# Transform aspect from degrees to radians
merged_df$aspect_mean_rad <- merged_df$aspect_mean*pi/180
```


```{r filtering_08, include=FALSE}
filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>%
  filter(format(datetime, "%m-%d") >= "05-01" & format(datetime, "%m-%d") <= "07-31")

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

## Model 1: High flows - HUMIC

```{r filtering_08.1, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>%
  filter(format(datetime, "%m-%d") >= "05-01" & format(datetime, "%m-%d") <= "07-31")

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (total stream n= 91)

**ABOUT THIS MODEL**
- stream samples during peak flows (May 1 - July 31) n=33
- response is HUMIC. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Runoff** <br>
-- log_discharge_m2 <br>
**Landcover:** <br>
-- % of subcatchment pixels with beetle kill and  harvested/regenerating vegetation
**Nutrient:**
-- nitrate [NO3]mg/L in water sample
Usually the dominant form of dissolved N exported from forests via streams(Ryan and Lawrence, 2024). stimulates microbial activity, potentially reducing the fraction on labile carbon in the water column. Microbes can polymerize or oxydize simpler carbon molecules producing humic-like substances that are more recalcitrant (T.C. Balser 2005).
**HUMIC:** <br>
-- "PARAF_comp_1" = total loading of humic component 1. A 'total loading' is a number that tells us how much of a particular compoent is present in a particular sample.<br>  -- "PARAF_comp_2" = total loading of humic component 2. <br> -- "relative_load_comp_1", = the fraction of the total sample absorbance by component 1 <br>
-- "relative_load_comp_2", = the fraction of the total sample absorbance by component 2 <br>
-- "Fluorescence_Index" = fluorescence index (FI) as the ratio of emission intensities at ex=370 em=470: ex370 em520 (cory et al. 2010)<br>

```{r runthemodel_08.1, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  runoff = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating"),
  humic = c( "relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index", "SUVA254"),
#  Cfix_ions = c("Mg_mg.l", "Ca_mg.l"),
  Cgen_nutr = c('NO3_mg.l') #"peak_C_350.450",
)


# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("RUNOFF",  multi_items("runoff_", 1:1)), #single_item("runoff_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
#  composite("F_IONS", multi_items("Cfix_ions_", 1:2)),
  composite("HUMIC",  multi_items("humic_", 1:4)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("RUNOFF", "LANDCOVER",  "NUTRIENT")), #"F_IONS",
paths(from = c("LANDCOVER"), to = c("RUNOFF",  "HUMIC", "NUTRIENT")), #"F_IONS",
paths(from = c("RUNOFF"), to = c("HUMIC")),
#paths(from =c("F_IONS"), to = c("HUMIC")),
paths(from =c("NUTRIENT"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nHigh flow - Humic")
par(old_par)
```

## Model 2: LOW FLOWS - streams

```{r filtering_08.2, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>% 
  filter((format(datetime, "%m-%d") >= "08-01" & format(datetime, "%m-%d") <= "12-31") | (format(datetime, "%m-%d") >= "01-01" & format(datetime, "%m-%d") <= "04-30"))


filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

**ABOUT THIS MODEL**
- stream samples during low flows (August 1 - April 30) n=58
- response is HUMIC. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Runoff** <br>
-- log_discharge_m2 <br>
**Landcover:** <br>
-- % of subcatchment pixels with beetle kill and  harvested/regenerating vegetation
**Nutrient:**
-- nitrate [NO3]mg/L in water sample
Usually the dominant form of dissolved N exported from forests via streams(Ryan and Lawrence, 2024). stimulates microbial activity, potentially reducing the fraction on labile carbon in the water column. Microbes can polymerize or oxydize simpler carbon molecules producing humic-like substances that are more recalcitrant (T.C. Balser 2005).
**HUMIC:** <br>
-- "PARAF_comp_1" = total loading of humic component 1. A 'total loading' is a number that tells us how much of a particular compoent is present in a particular sample.<br>  -- "PARAF_comp_2" = total loading of humic component 2. <br> -- "relative_load_comp_1", = the fraction of the total sample absorbance by component 1 <br>
-- "relative_load_comp_2", = the fraction of the total sample absorbance by component 2 <br>
-- "Fluorescence_Index" = fluorescence index (FI) as the ratio of emission intensities at ex=370 em=470: ex370 em520 (cory et al. 2010)<br>
-- "SUVA254" = UV absorbance at 254 nm (SUVA254) normalized by DOC concentration: reflects the aromaticity level of DOM


```{r runthemodel_08.2, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  runoff = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating"),
  humic = c( "PARAF_comp_1", "PARAF_comp_2","relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index"), #, "SUVA254"
#  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_df and add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("RUNOFF",  multi_items("runoff_", 1:1)), #single_item("runoff_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
 # composite("F_IONS", multi_items("Cfix_ions_", 1:2)),, "SUVA254"
  composite("HUMIC",  multi_items("humic_", 1:5)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("RUNOFF", "LANDCOVER",  "NUTRIENT")),#"F_IONS",
paths(from = c("LANDCOVER"), to = c("RUNOFF",  "HUMIC", "NUTRIENT")),#"F_IONS",
paths(from = c("RUNOFF"), to = c("HUMIC")),
#paths(from =c("F_IONS"), to = c("HUMIC")),
paths(from =c("NUTRIENT"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nLow flow - Humic")
par(old_par)
```

```{r}

```

## Model 3: LABILE high flows - streams 

**ABOUT THIS MODEL**
- stream samples during peak flows (May 1 - July 31) n=33
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Runoff** <br>
-- log_discharge_m2 <br>
**Landcover:** <br>
-- % of subcatchment pixels with beetle kill and  harvested/regenerating vegetation
**Nutrient:**
-- nitrate [NO3]mg/L in water sample
**LABILE**
-- "norm_PARAF_c3", "PARAF_comp_3",  "relative_load_comp_3",  "Fluorescence_Index", "SUVA254", "peak_ratioAT", "peak_ratioCT"

```{r filtering_08.3, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>%
  filter(format(datetime, "%m-%d") >= "05-01" & format(datetime, "%m-%d") <= "07-31")

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed
```


```{r runthemodel_08.3, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  runoff = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating", "percent_Old.Forest", "percent_Tundra"),
  labile = c("relative_load_comp_3",  "Fluorescence_Index", "PARAF_comp_1", "PARAF_comp_2","relative_load_comp_1", "relative_load_comp_2"),
  #Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("RUNOFF",  multi_items("runoff_", 1:1)), #single_item("runoff_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  #composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("LABILE",  multi_items("labile_", 1:6)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("RUNOFF", "LANDCOVER",  "NUTRIENT")),#"F_IONS",
paths(from = c("LANDCOVER"), to = c("RUNOFF",  "LABILE", "NUTRIENT")), #"F_IONS",
paths(from = c("RUNOFF"), to = c("LABILE")),
#paths(from =c("F_IONS"), to = c("LABILE")),
paths(from =c("NUTRIENT"), to = c("LABILE"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nHigh flow - LABILE")
par(old_par)
```

## Model 4: LABILE LOW FLOWS - streams

```{r filtering_08.4, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>% 
  filter((format(datetime, "%m-%d") >= "08-01" & format(datetime, "%m-%d") <= "12-31") | (format(datetime, "%m-%d") >= "01-01" & format(datetime, "%m-%d") <= "04-30"))


filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Runoff** <br>
-- log_discharge_m2 <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**LABILE:** <br>

```{r runthemodel_08.4, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
# indicators same as previous model

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_df and add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

# simple_FEF_mm same as above

# Create structural model
# simple_FEF_sm same as above

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 10000,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nLow flow - LABILE")
par(old_par)
```

```{r}

```
