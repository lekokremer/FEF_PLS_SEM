# PLS-SEM FEF HUMIC model iterations

```{r pkgs7, include=FALSE}
# pkgTest is a helper function to load packages and install packages only when they are not installed yet.
pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

#"rstan", "devtools", "tidyverse",  "ggpmisc", "reshape2", 
neededPackages <- c('seminr', 'tidyr', 'dplyr', 'lubridate', 'ggplot2')

for (package in neededPackages){pkgTest(package)}

```


```{r import_data7, include = FALSE}
# IMPORT PARAFAC results
# Move up one directory from the current working directory
#file <- normalizePath(file.path(getwd(), "../PARAFAC/df_loadings.csv"))
file <- normalizePath(file.path(getwd(), "datafiles/df_loadings.csv"))
parafac <- read.csv(file, header = TRUE, sep = ",", quote = "\"",
         dec = ".", fill = TRUE) %>%
  # Widen the parafac dataframe
  #pivot_wider(names_from = Component, values_from = Proportion) %>%
  # Extract the sample no. to match other dataframe
  mutate(ID = substr(Sample, nchar(Sample) - 2, nchar(Sample)))
```

```{r import_data7b, include = FALSE}

# Move up one directory from the current working directory
file <- normalizePath(file.path(getwd(), "/datafiles/fluoro_topo_melt_PARAFAC.csv"))

# Read the CSV file
sample_vege_fluro_topo <- read.csv(file) 

```

```{r Merge_dataframes7, include=FALSE}
# Merge vegetation, topography and fluoro data with PARAFAC results. 
partial_df <- merge(sample_vege_fluro_topo, parafac, by='ID')%>%
  mutate(across(c(watershed, reach, position, TYPE), as.factor))%>%
  mutate(datetime = ymd(date))

partial_df <- partial_df %>%
  mutate(
    percent_Beetle.kill = replace_na(percent_Beetle.kill, 0),
    percent_Old.Forest = replace_na(percent_Old.Forest, 0),
    percent_cut.regenerating = replace_na(percent_cut.regenerating, 0),
    percent_Tundra = replace_na(percent_Tundra, 0),
    percent_Meadows = replace_na(percent_Meadows, 0)
  )
```

```{r, merge_dataframes7b, include=FALSE}
#ADD BOD data
file <- normalizePath(file.path(getwd(), "/datafiles/BODrates_cleaned.csv"))

# Read the CSV file
bod <- read.csv(file) %>%
  dplyr::select(-watershed)

# Merge PARAFAC, vegetation, topography and fluoro data with BOD results. 
merged_df <- merge(partial_df, bod, by='ID',, all.x = TRUE )

```

```{r Formatting_subsetting7, include=FALSE}
# Generate a discharge column that is normalized by the area of the respective watershed.
merged_df<- merged_df%>%
  mutate(Qm3_s = replace_na(Qm3_s, 0.005)) %>%
  dplyr::select(-c(PARAF_comp_1.x, PARAF_comp_2.x, PARAF_comp_3.x, total_loadings.x, Sample.x, relative_load_comp_1.x, relative_load_comp_2.x, relative_load_comp_3.x)) %>% #remove duplicate columns
  rename_with(~ gsub("\\.y$", "", .), ends_with(".y")) #removes .y from names 

merged_df$discharge_m2 <- merged_df$Qm3_s/merged_df$area_m
merged_df$Input.mm_m2 <- merged_df$Input.mm/merged_df$area_m
merged_df$snowpack_m2 <- merged_df$snowpack_3day_avg/merged_df$area_m

# Transform aspect from degrees to radians
merged_df$aspect_mean_rad <- merged_df$aspect_mean*pi/180

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )#%>%
  #filter(datetime >= as.POSIXct('2022-06-10 00:10') & datetime <= as.POSIXct('2022-09-15 23:00'))

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

Building on part 06_PLS_SEM, building responses using 'labile' and 'recalcitrant' indicators. 
Potential responses are from: <br>
**1. EEMS:** "peak_A_250.450", "peak_C_350.450", "peak_T_275.340",         "Fluorescence_Index", "SUVA254", "peak_ratioAT", "peak_ratioCA","peak_ratioCT" <br>
<u>Where: peak_A_250.450 and peak_C_350.450</u> are typically intersections on the emission-excitation matrix where a peak is associated with the presence humic-like substances. It is an indicator of humic content, which generally represents more refractory/recalcitrant (less biodegradable) dissolved organic matter (DOM). PeaK C may be less degraded, more recently produced (younger or more microbially souced?). Peak A may be more degraded,older derived from terrestrail souces with longer residence time. <br>
<u>peak_T_275_340</u> - indicator of protein-like substances (tryptophan) and can be an indicator of recently produced, labile DOM.<br>
<u>Fluorescence_Index:</u> helps distinguish between terrestrial and microbial sources of dissolved organic matter (DOM). It is the ratio of fluorescence intensities at emission 475 with excitation at 370 nm. <br>
FI around 1.2 or lower: Indicates a stronger terrestrial DOM source, often linked to plant and soil organic matter inputs. <br>
FI around 1.4 or higher: Suggests a more microbial DOM source, often derived from algae, bacteria, or other microbial production.<br>
Microbially derived DOM is generally more labile than terrestrial DOM.<br>
<u>SUVA:</u> is specific Ultraviolet Absorbance at 254nm (absorbance at 254nm normalized by DOC concentration) and is an indicator of aromacity (>4L/mg.m) is higher aromatic content, usually associated with terrestrial, humic-like DOM, where lower (<2-3L/mg.m) is usually associated with microbial, more labile sources.<br>
<u>Peak ratios:</u> are ratios of the peaks A, C and T to get an idea of the relative abundances of humic: protein-like substances.<br>
**PARAFAC:** norm_loadings, norm_PARAF_c1, norm_PARAF_c2, norm_PARAF_c3,          PARAF_comp_1, PARAF_comp_2, PARAF_comp_3, total_loadings, Sample,                  relative_load_comp_1, relative_load_comp_2, relative_load_comp_3  <br>  
<u>Where: total_loadings </u> refers to the total absorbance of the entire sample, <u>norm_loadings </u> are the loadings normalized by the sample DOC concentration, and 'relative load' refers to the fraction of the total loading represented by each component. Component 1, 2 and 3 matrices are shown in section 3. 1 and 2 represent humic components. Component 3 matches protein-like component matrices.<br> 
**BOD:** daily_DOC_loss, daily_rate_of_change_Ox <br>
Total DOC consumed during biological oxygen demand assays were measured and normalized by the number of days that the experiment was run. Similarly, dissolved oxygen (DO) was measured at 10minute intervals, then a DO loss per day was calculated for each sample (04_BOD_results_summary). Preliminary data exploration suggests that few correlations exist between BOD results and other responses, or landscape characteristics, except maybe DOC normalized PARAFAC component loadings. <br>

To generate a two model analysis, I will group measured responses (i.e.indicators) into 'humic' or 'protein-like' latent variables. Then we will evaluate the relatedness of each indicator within the two variables to determine how each latent variable should be defined. PLS-SEM iteratively assigns weights to each indicator to maximize the explained variance of the latent variable in the structural model (this process is conceptually similar to PCA). In the bootstrapped model, we will see the strength of the relationship between each indicator and composite represented by lambda. So lambda indicates how well each indicator “loads” on its assigned latent variable after optimization (like PCA factor loadings). Higher lambda values mean that the indicator is strongly associated with the composite.<br>

**potential humic indicators:** "norm_PARAF_c1", "norm_PARAF_c2", "PARAF_comp_1", "PARAF_comp_2", relative_load_comp_1", "relative_load_comp_2", "daily_rate_of_change_Ox", "daily_DOC_loss", "peak_A_250.450", "peak_C_350.450", "Fluorescence_Index", "SUVA254", "peak_ratioCA" <br>

**potential microbial/labile indicators:** "norm_PARAF_c3", "PARAF_comp_3",  "relative_load_comp_3", "daily_rate_of_change_Ox", "daily_DOC_loss", "peak_T_275.340", "Fluorescence_Index", "SUVA254", "peak_ratioAT", "peak_ratioCT" <br>

## Model 1 - test all HUMIC indicators

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
-- mean distance that allochthonous water has to travel to the stream channel<br>
-- mean aspect in radians<br>
-- mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI <br>
**Hydro:** <br>
--log discharge/m2<br>
**Humic DOM:** <br>
-- "norm_PARAF_c1", "norm_PARAF_c2", "PARAF_comp_1", "PARAF_comp_2", relative_load_comp_1", "relative_load_comp_2", "peak_A_250.450", "peak_C_350.450", "Fluorescence_Index", "SUVA254", "peak_ratioCA" <br>

Removed from list of potential response variables "daily_rate_of_change_Ox", "daily_DOC_loss", too many NA to include in this model
```{r runthemodel_07.1, include=FALSE}
# Initialize model_df with the same number of rows as filtered_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  humic = c("norm_PARAF_c1", "norm_PARAF_c2", "PARAF_comp_1", "PARAF_comp_2", "relative_load_comp_1", "relative_load_comp_2", "peak_A_250.450", "peak_C_350.450", "Fluorescence_Index", "SUVA254", "peak_ratioCA")
)
# "daily_rate_of_change_Ox", "daily_DOC_loss",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("HUMIC",  multi_items("humic_", 1:11))# single_item('dom_1'))#,
  #composite("STAGE", multi_items("stage_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "HUMIC")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "HUMIC")),
paths(from = c("HYDRO"), to = c("HUMIC"))
)

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary <br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r modelsummary_07.1, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo=FALSE}
plot(summary_simple_fef$reliability)
```

```{r, include=FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

Inspect the bootstrapped indicator loadings

```{r, include=FALSE}
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)
```

Here we are interested in the indicator loadings for DOM. We can see lambda values that are low and insignificant (e.g. dom_1 = norm_PARAF_c1 = DOM normalized absorbance for component 1.), but most are > than |0.5| and significant. Let's remove insignificant indicators and see what happens: 


## Model 2 - remove non-significant indicators

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI <br>
**Hydro:** <br>
--log discharge/m2<br>
**HUMIC:** <br>
--"PARAF_comp_1", "PARAF_comp_2", relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index", "SUVA254", "peak_ratioCA"
"peak_C_350.450",
```{r runthemodel_07.2, include=FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  humic = c("PARAF_comp_1", "PARAF_comp_2", "relative_load_comp_1", "relative_load_comp_2", "Fluorescence_Index", "SUVA254")
)

# "daily_rate_of_change_Ox", "daily_DOC_loss",  "peak_C_350.450", , "peak_ratioCA", "norm_PARAF_c2",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("HUMIC",  multi_items("humic_", 1:6))# single_item('dom_1'))#,
  #composite("STAGE", multi_items("stage_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "HUMIC")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "HUMIC")),
paths(from = c("HYDRO"), to = c("HUMIC"))
)

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")

# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

Output summary <br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

A plot of result reliability measures:
```{r modelsummary_07.2, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r,echo=FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

Inspect the bootstrapped indicator loadings

```{r, include=FALSE}
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)
```

This combination of indicators provides a reliable and valid measurement of the 'humic' construct/latent variable, as indicated by significant loadings, AVE > 0.5, and high reliability metrics (RhoC, alpha, and rhoA > 0.7). The significant lambda values indicate that each indicator meaningfully contributes to and effectively represents the 'humic' construct. This suggests a strong relationship between the latent variable and its indicators, confirming that the indicators are well-aligned with the underlying concept of 'humic'. <br>

Other values in the model: <br>
**beta coefficients** also called path coefficients represent the strength and direction of the relationship between the latent variables, similar to regression coefficients. So a higher B coefficient suggests a stronger predictive influence of the independent/predictor construct on the dependent construct.

**R^2 values** aka the coefficient of determination. This is the amount of variance in that construct explained by its predictor constructs. In other words, it is the combined effect of all predictors on that construct. 
So in this example 45% of the variance in HUMIC is explained by topography, landcover and discharge. 

In this example, the landcover indicator is '% Beetle kill coverage'. Let's test other landcover indicators to see if any others are better predictors of DOM. We can do this in a loop where we test different sets of landcover indicators and print the model summaries to compare coefficients.

## Model 3 - loop through landcover

```{r runthemodel_07.3, echo = FALSE, message=FALSE, warning=FALSE}
# Define different sets of landcover indicators to test
landcover_sets <- list(
  allperc = c("percent_Beetle.kill", "percent_cut.regenerating", "percent_Tundra","percent_Meadows", "percent_Old.Forest"),
  VIMI = c("ndvi_raster_mean", "ndmi_raster_mean"),
  allcanopy = c("percent_1.5", "percent_6.10","percent_11.15", "percent_.15")
  # Add more sets as needed
)

# Loop through each set of landcover indicators
results <- list()  # Store results in a list for later inspection

for (set_name in names(landcover_sets)) {
  # Update the indicators list for the current set of landcover indicators
  indicators <- list(
    topo = c("disttostreams_mean", "aspect_mean_rad", "twi_mean"),
    hydro = c("log_discharge_m2"),
    landcover = landcover_sets[[set_name]],  # Use current set of landcover indicators
    humic = c("PARAF_comp_1", "PARAF_comp_2", 
              "relative_load_comp_1", "relative_load_comp_2", 
               "Fluorescence_Index", "SUVA254", "peak_ratioCA")
  )
  
  # Initialize a temporary model_df for the current set of indicators
  model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))
  
  # Populate model_df with indicators
  for (indicator in names(indicators)) {
    variables <- indicators[[indicator]]
    for (i in seq_along(variables)) {
      old_name <- variables[i]
      new_name <- paste0(indicator, "_", i)
      
      if (old_name %in% colnames(filtered_df)) {
        model_df[[new_name]] <- filtered_df[[old_name]]
      } else {
        warning(paste("Column", old_name, "not found in filtered_df"))
      }
    }
  }
  
  # Standardize the model_df
  model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))
  
  # Define the measurement model
  simple_FEF_mm <- constructs(
    composite("TOPO", multi_items("topo_", 1:3)),
    composite("HYDRO", single_item("hydro_1")),
    composite("LANDCOVER", multi_items("landcover_", 1:length(landcover_sets[[set_name]]))),
    composite("HUMIC", multi_items("humic_", 1:7))
  )
  
  # Estimate the model
  fef_simple_model <- estimate_pls(
    data = model_df_standardized,
    measurement_model = simple_FEF_mm,
    structural_model = simple_FEF_sm,
    inner_weights = path_weighting,
    missing = mean_replacement,
    missing_value = "NA"
  )
  
  # Store the summary results, adding an identifier for the landcover set tested
  results[[set_name]] <- summary(fef_simple_model)
  
  # Print or inspect the model summary
  cat("\nResults for landcover indicators:", set_name, "\n")
  print(results[[set_name]]$paths)    # Path coefficients
  print(results[[set_name]]$r2)       # R² values
  print(results[[set_name]]$reliability)  # Reliability metrics, if needed
}
```

What we see in this output is that other landcover types like tundra, meadows and old forest % coverage do not generate reliable and valid measurements of the 'landcover' construct/latent variable, as indicated by low loadings, (AVE < 0.5), and/or low reliability metrics (RhoC, alpha, and rhoA < 0.7). If we evaluate the R^2 for each of our dependent variables, specifically HUMIC to determine the amount of variance in that construct explained by its predictor constructs...we see that old forest and beetle kill seem to have similar, weak effects on the 'HUMIC' construct, with similar prediction strength from the other latent variables. 

Bootstrap the best output
```{r, include=FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating", "percent_Old.Forest", "percent_Tundra", "percent_Meadows"),
  humic = c("PARAF_comp_1", "PARAF_comp_2", "relative_load_comp_1", "relative_load_comp_2", "peak_C_350.450", "Fluorescence_Index", "SUVA254", "peak_ratioCA")
)
# "daily_rate_of_change_Ox", "daily_DOC_loss",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:5)),
  composite("HUMIC",  multi_items("humic_", 1:8))# single_item('dom_1'))#,
  #composite("STAGE", multi_items("stage_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "HUMIC")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "HUMIC")),
paths(from = c("HYDRO"), to = c("HUMIC"))
)

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")

# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

plot(summary_simple_fef$reliability)
```

```{r, include=FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

Inspect the bootstrapped indicator loadings

```{r, include=FALSE}
#sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)
```

## Model 4 - Flow state model
Adds flow state as classifier as a latent variable.  <br>
To include classifications in a PLS model, we generate a column in the dataset for each classification, and a binomial indicators in each row. For example, of the flow state at the time of sampling is just after peak flow, that sample will have a '1' in the upper descending limb column, and a '0' in all others. Potential classifications are 'rising limb', 'upper descending limb', 'lower descending limb' and baseflow. In the path model, lower_decreasing = state_1, upper_decreasing = state_2, increasing = state_3. These classifications were developed by finding the date of peak flow for the respective year and stream, and the dates for the end and beginning of baseflow for each calendar year. Then the 'midway' point between peakflow and the first date of baseflow delineates upper and lower descending limbs. (find the name of this script, pretty sure its an .ipynb)
Build the outer model or 'constructs' or latent variables

This script cycles through multiple landcover indicators, saving the summary results for each run to a dataframe 'results'. The first several model summaries are printed. We find that no models that include 'flow state' have sufficient reliability measures. I have tried a 'flow state' construct with all indicators (rising limb, upper descending limb, lower descending limb, baseflow) and with the two most common in our sample set (lower descending limb, baseflow). If reliability is low, it means the construct is not accurately or consistently representing the latent variable, which can have significant implications for the results and interpretations. 

```{r, include=FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating", "percent_Old.Forest", "percent_Tundra", "percent_Meadows"),
  state = c('baseflow', 'lower_decreasing', 'upper_decreasing', "increasing"),
  humic = c("PARAF_comp_1", "PARAF_comp_2", "relative_load_comp_1", "relative_load_comp_2", "peak_C_350.450", "Fluorescence_Index", "SUVA254", "peak_ratioCA")
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:5)),
  composite("STATE", multi_items("state_", 1:4)),
  composite("HUMIC",  multi_items("humic_", 1:8))# single_item('dom_1'))#,
  #composite("STAGE", multi_items("stage_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "HUMIC")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "HUMIC")),
paths(from = c("STATE"), to = c("HYDRO", "HUMIC")),
paths(from = c("HYDRO"), to = c("HUMIC"))
)

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")

# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)
```


```{r, include=FALSE}
plot(summary_simple_fef$reliability)
```


Interpretation: The current classification of flow states does not yield a reliable latent variable. Let's try splitting high and low flows 

## Model 5: HUMIC early season - streams 

```{r filtering_07.5, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>%
  filter(format(datetime, "%m-%d") >= "05-01" & format(datetime, "%m-%d") <= "07-31")

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed
```

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is HUMIC. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Hydro** <br>
-- log_discharge_m2
-- distance.to.outlet
**Landcover:** <br>
-- % of subcatchment pixels with Beetle.kill", "percent_cut.regenerating","percent_Old.Forest", "percent_Tundra"
-- and harvested/regenerating vegetation
**LABILE:** <br>
-- "PARAF_comp_1", "PARAF_comp_2","peak_C_350.450", "relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index", "SUVA254"
**Cfix_ions**
-- ions that compound with C to increase recalcitrance
**Cgen_nutr**
-- NO3_mg.l

```{r runthemodel_07.5, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2", "distance.to.outlet"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating","percent_Old.Forest", "percent_Tundra"),
  humic = c( "PARAF_comp_1", "PARAF_comp_2","peak_C_350.450", "relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index", "SUVA254"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO",  multi_items("hydro_", 1:2)), #single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("HUMIC",  multi_items("humic_", 1:6)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "F_IONS", "NUTRIENT")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "F_IONS", "HUMIC", "NUTRIENT")),
paths(from = c("HYDRO"), to = c("HUMIC")),
paths(from =c("F_IONS"), to = c("HUMIC")),
paths(from =c("NUTRIENT"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nHigh flow - Humic")
par(old_par)
```

## Model 6: HUMIC late season - streams

```{r filtering_07.6, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>% 
  filter((format(datetime, "%m-%d") >= "08-01" & format(datetime, "%m-%d") <= "12-31") | (format(datetime, "%m-%d") >= "01-01" & format(datetime, "%m-%d") <= "04-30"))


filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is HUMIC. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**LABILE:** <br>

```{r runthemodel_07.6, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2", "distance.to.outlet"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating","percent_Old.Forest", "percent_Tundra"),
  humic = c( "PARAF_comp_1", "PARAF_comp_2","peak_C_350.450", "relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index", "SUVA254"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_df and add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO",  multi_items("hydro_", 1:2)), #single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("HUMIC",  multi_items("humic_", 1:6)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "F_IONS", "NUTRIENT")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "F_IONS", "HUMIC", "NUTRIENT")),
paths(from = c("HYDRO"), to = c("HUMIC")),
paths(from =c("F_IONS"), to = c("HUMIC")),
paths(from =c("NUTRIENT"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nLow flow - Humic")
par(old_par)
```

```{r}

```

