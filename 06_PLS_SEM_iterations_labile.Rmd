---
title: "PLS-SEM FEF LABILE model iterations"
author: "Lauren Kremer"
date: "2024-10-27"
output: html_document
---

# PLS-SEM FEF LABILE model iterations

```{r pkgs6, include=FALSE}
# pkgTest is a helper function to load packages and install packages only when they are not installed yet.
pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

#"rstan", "devtools", "tidyverse",  "ggpmisc", "reshape2", 
neededPackages <- c('seminr', 'tidyr', 'dplyr', 'lubridate', 'ggplot2')

for (package in neededPackages){pkgTest(package)}

```


```{r import_data6, include = FALSE}
# IMPORT PARAFAC results
# Move up one directory from the current working directory
#file <- normalizePath(file.path(getwd(), "../PARAFAC/df_loadings.csv"))
file <- normalizePath(file.path(getwd(), "datafiles/df_loadings.csv"))
parafac <- read.csv(file, header = TRUE, sep = ",", quote = "\"",
         dec = ".", fill = TRUE) %>%
  # Widen the parafac dataframe
  #pivot_wider(names_from = Component, values_from = Proportion) %>%
  # Extract the sample no. to match other dataframe
  mutate(ID = substr(Sample, nchar(Sample) - 2, nchar(Sample)))
```

```{r import_data6b, include = FALSE}

# Move up one directory from the current working directory
file <- normalizePath(file.path(getwd(), "/datafiles/fluoro_topo_melt_PARAFAC.csv"))

# Read the CSV file
sample_vege_fluro_topo <- read.csv(file) 

```

```{r Merge_dataframes6, include=FALSE}
# Merge vegetation, topography and fluoro data with PARAFAC results. 
partial_df <- merge(sample_vege_fluro_topo, parafac, by='ID')%>%
  mutate(across(c(watershed, reach, position, TYPE), as.factor))%>%
  mutate(datetime = ymd(date))

partial_df <- partial_df %>%
  mutate(
    percent_Beetle.kill = replace_na(percent_Beetle.kill, 0),
    percent_Old.Forest = replace_na(percent_Old.Forest, 0),
    percent_cut.regenerating = replace_na(percent_cut.regenerating, 0),
    percent_Tundra = replace_na(percent_Tundra, 0),
    percent_Meadows = replace_na(percent_Meadows, 0)
  )
```

```{r merge_dataframes6b, include=FALSE}
#ADD BOD data
file <- normalizePath(file.path(getwd(), "/datafiles/BODrates_cleaned.csv"))

# Read the CSV file
bod <- read.csv(file) %>%
  dplyr::select(-watershed)

# Merge PARAFAC, vegetation, topography and fluoro data with BOD results. 
merged_df <- merge(partial_df, bod, by='ID',, all.x = TRUE )

```

```{r Formatting_subsetting6, include=FALSE}
# Generate a discharge column that is normalized by the area of the respective watershed.
merged_df<- merged_df%>%
  mutate(Qm3_s = replace_na(Qm3_s, 0.005)) %>%
  dplyr::select(-c(PARAF_comp_1.x, PARAF_comp_2.x, PARAF_comp_3.x, total_loadings.x, Sample.x, relative_load_comp_1.x, relative_load_comp_2.x, relative_load_comp_3.x)) %>% #remove duplicate columns
  rename_with(~ gsub("\\.y$", "", .), ends_with(".y")) #removes .y from names 

merged_df$discharge_m2 <- merged_df$Qm3_s/merged_df$area_m
merged_df$Input.mm_m2 <- merged_df$Input.mm/merged_df$area_m
merged_df$snowpack_m2 <- merged_df$snowpack_3day_avg/merged_df$area_m

# Transform aspect from degrees to radians
merged_df$aspect_mean_rad <- merged_df$aspect_mean*pi/180

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )#%>%
  #filter(datetime >= as.POSIXct('2022-06-10 00:10') & datetime <= as.POSIXct('2022-09-15 23:00'))

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

Building on part 07_PLS_SEM, building responses using 'labile' indicators. 

potential microbial/labile indicators: "norm_PARAF_c3", "PARAF_comp_3",  "relative_load_comp_3", "daily_rate_of_change_Ox", "daily_DOC_loss", "peak_T_275.340", "Fluorescence_Index", "SUVA254", "peak_ratioAT", "peak_ratioCT"

## Model 1 - test all LABILE indicators

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI <br>
**Hydro:** <br>
--log discharge/m2<br>
**Labile DOM:** <br>
-- "norm_PARAF_c3", "PARAF_comp_3",  "relative_load_comp_3", "peak_T_275.340", "Fluorescence_Index", "SUVA254", "peak_ratioAT", "peak_ratioCT"

Removed from list of potential response variables "daily_rate_of_change_Ox", "daily_DOC_loss", too many NA to include in this model
```{r runthemodel_06.1, include=FALSE}
# Initialize model_df with the same number of rows as filtered_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  labile = c("norm_PARAF_c3", "relative_load_comp_3", "peak_T_275.340", "Fluorescence_Index", "SUVA254", "peak_ratioAT", "peak_ratioCT")
)
# "daily_rate_of_change_Ox", "daily_DOC_loss",
#"PARAF_comp_3", 
# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("LABILE",  multi_items("labile_", 1:7))# single_item('dom_1'))#,
  #composite("STAGE", multi_items("stage_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "LABILE")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "LABILE")),
paths(from = c("HYDRO"), to = c("LABILE"))
)

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary <br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

We can see in this plot that our reliability indicators are too low with this combination of indicators.  

```{r, include = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, include=FALSE}
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Here we are interested in the indicator loadings for DOM. We can see lambda values that are low and insignificant (e.g. dom_1 = norm_PARAF_c1 = DOM normalized absorbance for component 1.), but most are > than |0.5| and significant. Let's remove insignificant indicators and see what happens: 


## Model 2 - remove non-significant indicators

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI <br>
**Hydro:** <br>
--log discharge/m2<br>
**DOM:** <br>
-- "norm_PARAF_c3", "PARAF_comp_3",  "relative_load_comp_3", "Fluorescence_Index", "peak_ratioAT", "peak_ratioCT"

```{r runthemodel_06.2, include=FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  labile = c("norm_PARAF_c3", "relative_load_comp_3",  "Fluorescence_Index",  "peak_ratioAT")
)

# "daily_rate_of_change_Ox", "daily_DOC_loss",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("LABILE",  multi_items("labile_", 1:4))# single_item('dom_1'))#,
  #composite("STAGE", multi_items("stage_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "LABILE")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "LABILE")),
paths(from = c("HYDRO"), to = c("LABILE"))
)

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")

# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

Output summary <br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, include = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, include=FALSE}
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

This combination of indicators provides a reliable and valid measurement of the 'labile' construct/latent variable, as indicated by significant loadings, AVE > 0.5, and high reliability metrics (RhoC, alpha, and rhoA > 0.7). The significant lambda values indicate that each indicator meaningfully contributes to and effectively represents the 'labile' construct. This suggests a strong relationship between the latent variable and its indicators, confirming that the indicators are well-aligned with the underlying concept of 'labile'. <br>

Other values in the model: <br>
**beta coefficients** also called path coefficients represent the strength and direction of the relationship between the latent variables, similar to regression coefficients. So a higher B coefficient suggests a stronger predictive influence of the independent/predictor construct on the dependent construct.

**R^2 values** aka the coefficient of determination. This is the amount of variance in that construct explained by its predictor constructs. In other words, it is the combined effect of all predictors on that construct. 
So in this example 45% of the variance in LABILE is explained by topography, landcover and discharge. 

In this example, the landcover indicator is '% Beetle kill coverage'. Let's test other landcover indicators to see if any others are better predictors of DOM. We can do this in a loop where we test different sets of landcover indicators and print the model summaries to compare coefficients.

## Model 3 - loop through landcover

```{r runthemodel_06.3, echo = FALSE}
# Define different sets of landcover indicators to test
landcover_sets <- list(
  allperc = c("percent_Beetle.kill", "percent_cut.regenerating", "percent_Tundra","percent_Meadows", "percent_Old.Forest"),
  VIMI = c("ndvi_raster_mean", "ndmi_raster_mean"),
  allcanopy = c("percent_1.5", "percent_6.10","percent_11.15", "percent_.15")
  # Add more sets as needed
)

# Loop through each set of landcover indicators
results <- list()  # Store results in a list for later inspection

for (set_name in names(landcover_sets)) {
  # Update the indicators list for the current set of landcover indicators
  indicators <- list(
    topo = c("disttostreams_mean", "aspect_mean_rad", "twi_mean"),
    hydro = c("log_discharge_m2"),
    landcover = landcover_sets[[set_name]],  # Use current set of landcover indicators
    labile = c("norm_PARAF_c3", "relative_load_comp_3",  "Fluorescence_Index",  "peak_ratioAT")
  )
  
  # Initialize a temporary model_df for the current set of indicators
  model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))
  
  # Populate model_df with indicators
  for (indicator in names(indicators)) {
    variables <- indicators[[indicator]]
    for (i in seq_along(variables)) {
      old_name <- variables[i]
      new_name <- paste0(indicator, "_", i)
      
      if (old_name %in% colnames(filtered_df)) {
        model_df[[new_name]] <- filtered_df[[old_name]]
      } else {
        warning(paste("Column", old_name, "not found in filtered_df"))
      }
    }
  }
  
  # Standardize the model_df
  model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))
  
  # Define the measurement model
  simple_FEF_mm <- constructs(
    composite("TOPO", multi_items("topo_", 1:3)),
    composite("HYDRO", single_item("hydro_1")),
    composite("LANDCOVER", multi_items("landcover_", 1:length(landcover_sets[[set_name]]))),
    composite("LABILE", multi_items("labile_", 1:4))
  )
  
  # Estimate the model
  fef_simple_model <- estimate_pls(
    data = model_df_standardized,
    measurement_model = simple_FEF_mm,
    structural_model = simple_FEF_sm,
    inner_weights = path_weighting,
    missing = mean_replacement,
    missing_value = "NA"
  )
  
  # Store the summary results, adding an identifier for the landcover set tested
  results[[set_name]] <- summary(fef_simple_model)
  
  # Print or inspect the model summary
  cat("\nResults for landcover indicators:", set_name, "\n")
  print(results[[set_name]]$paths)    # Path coefficients
  print(results[[set_name]]$r2)       # RÂ² values
  print(results[[set_name]]$reliability)  # Reliability metrics, if needed
}
```

What we see in this output is that other landcover types like tundra, meadows and old forest % coverage do not generate reliable and valid measurements of the 'labile' construct/latent variable, as indicated by low loadings, (AVE < 0.5), and/or low reliability metrics (RhoC, alpha, and rhoA < 0.7). If we evaluate the R^2 for each of our dependent variables, specifically LABILE to determine the amount of variance in that construct explained by its predictor constructs...we see that old forest and beetle kill seem to have similar, weak effects on the 'LABILE' construct, with similar prediction strength from the other latent variables. 

THis is just here to reproduce the  bootstrapped figures
```{r, include=FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_cut.regenerating", "ndvi_raster_mean"),
  labile = c("norm_PARAF_c3", "relative_load_comp_3",  "Fluorescence_Index",  "peak_ratioAT")
)
# "daily_rate_of_change_Ox", "daily_DOC_loss",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("LABILE",  multi_items("labile_", 1:4))# single_item('dom_1'))#,
  #composite("STAGE", multi_items("stage_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "LABILE")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "LABILE")),
paths(from = c("HYDRO"), to = c("LABILE"))
)

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")

# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

### Results of bootstrapped PLS

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

```{r, include=FALSE}
#sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

## Model 4 - Flow state model
Adds flow state as classifier as a latent variable.  <br>
To include classifications in a PLS model, we generate a column in the dataset for each classification, and a binomial indicators in each row. For example, of the flow state at the time of sampling is just after peak flow, that sample will have a '1' in the upper descending limb column, and a '0' in all others. Potential classifications are 'rising limb', 'upper descending limb', 'lower descending limb' and baseflow. In the path model, lower_decreasing = state_1, upper_decreasing = state_2, increasing = state_3. These classifications were developed by finding the date of peak flow for the respective year and stream, and the dates for the end and beginning of baseflow for each calendar year. Then the 'midway' point between peakflow and the first date of baseflow delineates upper and lower descending limbs. (find the name of this script, pretty sure its an .ipynb)
Build the outer model or 'constructs' or latent variables

This script cycles through multiple landcover indicators, saving the summary results for each run to a dataframe 'results'. The first several model summaries are printed. We find that no models that include 'flow state' have sufficient reliability measures. I have tried a 'flow state' construct with all indicators (rising limb, upper descending limb, lower descending limb, baseflow) and with the two most common in our sample set (lower descending limb, baseflow). If reliability is low, it means the construct is not accurately or consistently representing the latent variable, which can have significant implications for the results and interpretations. 

```{r runthemodel_06.4, echo = FALSE, warning=FALSE, message=FALSE}
# Define reliability threshold
reliability_threshold <- 0.5  # Adjust based on your needs

# Create a list to store models that meet reliability criteria
qualified_models <- list()  

# Loop through each set of landcover indicators
results <- list()  # Store results in a list for later inspection

# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
for (set_name in names(landcover_sets)) {
  indicators <- list(
    topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
    hydro = c("log_discharge_m2"),#log_discharge
    landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
    dom = c("norm_PARAF_c3", "relative_load_comp_3",  "Fluorescence_Index",  "peak_ratioAT"),
    state = c("lower_decreasing", "baseflow")
  )
#"baseflow", "lower_decreasing",
  # Loop through each indicator and rename columns
  for (indicator in names(indicators)) {
    variables <- indicators[[indicator]]
    for (i in seq_along(variables)) {
      old_name <- variables[i]
      new_name <- paste0(indicator, "_", i)
    
      if (old_name %in% colnames(filtered_df)) {
        model_df[[new_name]] <- filtered_df[[old_name]]
      } else {
        warning(paste("Column", old_name, "not found in filtered_df"))
      }
    }
  }

  # Standardizing the environmental variables
  model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))
  
  simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("DOM", multi_items('dom_', 1:4)),
  composite("STATE", multi_items("state_", 1:2))
)
  
    # Create structural model
  simple_FEF_sm <- relationships(
  paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "DOM")),
  paths(from = c("LANDCOVER"), to = c("HYDRO", "DOM")),
  paths(from = c("HYDRO"), to = c("DOM")),
  paths(from = c("STATE"), to = c("HYDRO", "DOM"))
  )
  
    # Estimate the model
  fef_simple_model <- estimate_pls(data = model_df_standardized,
  measurement_model = simple_FEF_mm,
  structural_model = simple_FEF_sm,
  inner_weights = path_weighting,
  missing = mean_replacement,
  missing_value = "NA")
  
# Calculate reliability metrics (e.g., Composite Reliability)
  model_summary <- summary(fef_simple_model)
  reliability_metrics <- model_summary$reliability  # Assuming it returns a data frame with relevant metrics
  
  # Check if all reliability metrics exceed the threshold
  if (all(reliability_metrics >= reliability_threshold, na.rm = TRUE)) {
    # Add to list of qualified models
    qualified_models[[set_name]] <- fef_simple_model
    
    # Optionally save to file for later use
    saveRDS(fef_simple_model, paste0("model_", set_name, ".rds"))
  }
  
  # Store summary results as usual
  results[[set_name]] <- model_summary
}
```

```{r, echo = FALSE}
print(results[1:3])
```







## Model 5: LABILE early season - streams 

```{r filtering_06.5, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>%
  filter(format(datetime, "%m-%d") >= "05-01" & format(datetime, "%m-%d") <= "07-31")

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed
```

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Hydro** <br>
-- log_discharge_m2
-- distance.to.outlet
**Landcover:** <br>
-- % of subcatchment pixels with Beetle.kill", "percent_cut.regenerating","percent_Old.Forest", "percent_Tundra"
-- and harvested/regenerating vegetation
**LABILE:** <br>
-- "PARAF_comp_1", "PARAF_comp_2","peak_C_350.450", "relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index", "SUVA254"
**Cfix_ions**
-- ions that compound with C to increase recalcitrance
**Cgen_nutr**
-- NO3_mg.l

```{r runthemodel_06.5, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2", "disttostreams_mean"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating", "percent_Old.Forest", "percent_Tundra"),
  labile = c("norm_PARAF_c3", "relative_load_comp_3",  "Fluorescence_Index",  "peak_ratioAT"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO",  multi_items("hydro_", 1:2)), #single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("LABILE",  multi_items("labile_", 1:4)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "F_IONS", "NUTRIENT")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "F_IONS", "LABILE", "NUTRIENT")),
paths(from = c("HYDRO"), to = c("LABILE")),
paths(from =c("F_IONS"), to = c("LABILE")),
paths(from =c("NUTRIENT"), to = c("LABILE"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nHigh flow - LABILE")
par(old_par)
```

## Model 6: LABILE late season - streams

```{r filtering_06.6, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>% 
  filter((format(datetime, "%m-%d") >= "08-01" & format(datetime, "%m-%d") <= "12-31") | (format(datetime, "%m-%d") >= "01-01" & format(datetime, "%m-%d") <= "04-30"))


filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**LABILE:** <br>

```{r runthemodel_06.6, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2", "distance.to.outlet"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating","percent_Old.Forest", "percent_Tundra"),
  labile = c("norm_PARAF_c3", "relative_load_comp_3",  "Fluorescence_Index",  "peak_ratioAT"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_df and add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO",  multi_items("hydro_", 1:2)), #single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("LABILE",  multi_items("labile_", 1:4)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "F_IONS", "NUTRIENT")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "F_IONS", "LABILE", "NUTRIENT")),
paths(from = c("HYDRO"), to = c("LABILE")),
paths(from =c("F_IONS"), to = c("LABILE")),
paths(from =c("NUTRIENT"), to = c("LABILE"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nLow flow - LABILE")
par(old_par)
```

```{r}

```

