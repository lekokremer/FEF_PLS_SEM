---
title: "PLS-SEM FEF model exploration and iterations"
author: "Lauren Kremer"
date: "2024-10-27"
output: html_document
---

# Testing iterations of the PLS-SEM FEF model

```{r pkgs, include=FALSE}
# pkgTest is a helper function to load packages and install packages only when they are not installed yet.
pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

#"rstan", "devtools", "tidyverse",  "ggpmisc", "reshape2", 
neededPackages <- c('seminr', 'tidyr', 'dplyr', 'lubridate', 'ggplot2')

for (package in neededPackages){pkgTest(package)}

```


```{r import_data, include = FALSE}
# IMPORT PARAFAC results
# Move up one directory from the current working directory
#file <- normalizePath(file.path(getwd(), "../PARAFAC/df_loadings.csv"))
file <- normalizePath(file.path(getwd(), "datafiles/df_loadings.csv"))
parafac <- read.csv(file, header = TRUE, sep = ",", quote = "\"",
         dec = ".", fill = TRUE) %>%
  # Widen the parafac dataframe
  #pivot_wider(names_from = Component, values_from = Proportion) %>%
  # Extract the sample no. to match other dataframe
  mutate(ID = substr(Sample, nchar(Sample) - 2, nchar(Sample)))
```

```{r import_data2, include = FALSE}

# Move up one directory from the current working directory
file <- normalizePath(file.path(getwd(), "/datafiles/fluoro_topo_melt_PARAFAC.csv"))

# Read the CSV file
sample_vege_fluro_topo <- read.csv(file) 

```

```{r Merge_dataframes, include=FALSE}
# Merge vegetation, topography and fluoro data with PARAFAC results. 
merged_df <- merge(sample_vege_fluro_topo, parafac, by='ID')%>%
  mutate(across(c(watershed, reach, position, TYPE), as.factor))%>%
  mutate(datetime = ymd(date))

merged_df <- merged_df %>%
  mutate(
    percent_Beetle.kill = replace_na(percent_Beetle.kill, 0),
    percent_Old.Forest = replace_na(percent_Old.Forest, 0),
    percent_cut.regenerating = replace_na(percent_cut.regenerating, 0),
    percent_Tundra = replace_na(percent_Tundra, 0),
    percent_Meadows = replace_na(percent_Meadows, 0)
  )
```

```{r Formatting_subsetting, include=FALSE}
# Generate a discharge column that is normalized by the area of the respective watershed.
merged_df<- merged_df%>%
  mutate(Qm3_s = replace_na(Qm3_s, 0.005)) %>%
  dplyr::select(-c(PARAF_comp_1.x, PARAF_comp_2.x, PARAF_comp_3.x, total_loadings.x, Sample.x, relative_load_comp_1.x, relative_load_comp_2.x, relative_load_comp_3.x)) %>% #remove duplicate columns
  rename_with(~ gsub("\\.y$", "", .), ends_with(".y")) #removes .y from names 

# Generate a discharge column that is normalized by the area of the respective watershed.
merged_df<- merged_df%>%
  mutate(Qm3_s = replace_na(Qm3_s, 0.005))

merged_df$discharge_m2 <- merged_df$Qm3_s/merged_df$area_m
merged_df$Input.mm_m2 <- merged_df$Input.mm/merged_df$area_m
merged_df$snowpack_m2 <- merged_df$snowpack_3day_avg/merged_df$area_m

# Transform aspect from degrees to radians
merged_df$aspect_mean_rad <- merged_df$aspect_mean*pi/180

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )#%>%
  #filter(datetime >= as.POSIXct('2022-06-10 00:10') & datetime <= as.POSIXct('2022-09-15 23:00'))

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)
The selection process for these variables includes review of the specific response variable, and the correlations of that variable with the explanatory variables found in combine_PARAFAC_w_ws, part 1.B.ii. 


## MODEL 1: include a collection of IONS as a latent variable where response is protein-like fraction of DOM.

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI<br>
**Hydro:** <br>
--log discharge/m2 <br>
**Ions:** <br>
-- "na_mg.l", "nh4_mg.l", "Mg_mg.l", "Ca_mg.l", "SO4_mg.l"
I would like to see if we can get nitrogen compounds, which theoretically can support microbial growth and enhance organic material in soil, increasing DOC export to streams. K+ can influence productivity(indirect source of allochthonous carbon?) and can stabilize some forms of DOM in soil, influencing what forms of carbon are leached to streams. I'm not sure that Na+ and Cl- really apply to our site...may not be directly involed with carbon transformations. I often see these as artifacts of human contribution.
Ca2+ and Mg2+ can also stabilize carbon by forming complexes with DOC, making it less reactive. 
**DOM:** <br>
-- fraction of protein-like component 

```{r, wholemodel_2, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  dom = c("relative_load_comp_3"),
  ions = c("nh4_mg.l", "Mg_mg.l", "Ca_mg.l", "SO4_mg.l")
)
#"slope_mean",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("IONS", multi_items("ions_", 1:4)),
  composite("DOM", single_item('dom_1'))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "DOM", "IONS")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "DOM", "IONS")),
paths(from = c("HYDRO"), to = c("IONS")),
paths(from =c("IONS"), to = c("DOM"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, echo = FALSE, warning=FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```

```{r}
Sys.sleep(1)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```


## MODEL 2: Change DOM to LABILE variable generated _labile chapter 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI <br>
**Hydro:** <br>
--log discharge/m2<br>
**Ions:**
--ions "Mg_mg.l", "Ca_mg.l", "SO4_mg.l"
**Labile DOM:** <br>
-- "norm_PARAF_c3", "PARAF_comp_3",  "relative_load_comp_3", "peak_T_275.340", "Fluorescence_Index", "SUVA254", "peak_ratioAT", "peak_ratioCT"


```{r, wholemodel_3, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  labile = c("norm_PARAF_c3", "relative_load_comp_3", "Fluorescence_Index"),
  ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l")
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("IONS", multi_items("ions_", 1:3)),
  composite("LABILE",  multi_items("labile_", 1:3))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "IONS", "LABILE")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "IONS", "LABILE")),
paths(from = c("HYDRO"), to = c("LABILE")),
paths(from =c("IONS"), to = c("LABILE"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```

```{r}
Sys.sleep(1)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

```{r}

```


Interpretation: 

## MODEL 3: LOOK AT MODEL 2 WITH HUMIC
Our indicators for each latent variable are as follows:<br>
Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI <br>
**Hydro:** <br>
--log discharge/m2<br>
**Ions:**
--ions "Mg_mg.l", "Ca_mg.l", "SO4_mg.l"
**Humic DOM:** <br>
--norm_PARAF_c1", "norm_PARAF_c2", "PARAF_comp_1", "PARAF_comp_2", relative_load_comp_1", "relative_load_comp_2", "peak_A_250.450", "peak_C_350.450", "Fluorescence_Index", "SUVA254", "peak_ratioCA

```{r, wholemodel_4, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  humic = c("norm_PARAF_c2", "PARAF_comp_1", "PARAF_comp_2", "relative_load_comp_1", "relative_load_comp_2", "peak_C_350.450", "Fluorescence_Index", "SUVA254", "peak_ratioCA"),
  ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l")
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("IONS", multi_items("ions_", 1:3)),
  composite("HUMIC",  multi_items("humic_", 1:8))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "IONS", "HUMIC")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "IONS", "HUMIC")),
paths(from = c("HYDRO"), to = c("HUMIC")),
paths(from =c("IONS"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, include = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r}
Sys.sleep(1)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Interpretation:
 <br>

Fool Creek only - streams, wells, both
Early season vs. late season, streams, wells, both


## MODEL 4: Change landcover types to all percentages, no NDVI
THIS WORKS WELL WITH JUST IONS, REVERT IF others don't work
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**LABILE:** <br>

```{r, wholemodel_5, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating","percent_Tundra" ),
  humic = c( "PARAF_comp_1", "PARAF_comp_2", "relative_load_comp_1", "relative_load_comp_2", "peak_C_350.450", "Fluorescence_Index", "SUVA254"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:3)),
  composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("HUMIC",  multi_items("humic_", 1:7)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "F_IONS", "NUTRIENT")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "F_IONS", "HUMIC", "NUTRIENT")),
paths(from = c("HYDRO"), to = c("HUMIC")),
paths(from =c("F_IONS"), to = c("HUMIC")),
paths(from =c("NUTRIENT"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r}
Sys.sleep(1)
```



```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Interpretation:

## MODEL 5: Early season - streams 

```{r filtering_06.5, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>%
  filter(format(datetime, "%m-%d") >= "05-01" & format(datetime, "%m-%d") <= "07-31")

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**LABILE:** <br>
```{r}
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating","percent_Tundra" ),
  humic = c( "PARAF_comp_1", "PARAF_comp_2", "relative_load_comp_1", "relative_load_comp_2", "peak_C_350.450", "Fluorescence_Index", "SUVA254"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)
```

```{r runthemodel_09.2, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2", "distance.to.outlet"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating"),
  humic = c( "PARAF_comp_1", "PARAF_comp_2","peak_C_350.450", "relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index", "SUVA254"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO",  multi_items("hydro_", 1:2)), #single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("HUMIC",  multi_items("humic_", 1:6)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "F_IONS", "NUTRIENT")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "F_IONS", "HUMIC", "NUTRIENT")),
paths(from = c("HYDRO"), to = c("HUMIC")),
paths(from =c("F_IONS"), to = c("HUMIC")),
paths(from =c("NUTRIENT"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nHigh flow - Humic")
par(old_par)
```

## MODEL 6: Late season - streams

```{r filtering_06.5, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>% 
  filter((format(datetime, "%m-%d") >= "08-01" & format(datetime, "%m-%d") <= "12-31") | (format(datetime, "%m-%d") >= "01-01" & format(datetime, "%m-%d") <= "04-30"))


filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**LABILE:** <br>

```{r runthemodel_06.6, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2", "distance.to.outlet"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating"),
  humic = c( "PARAF_comp_1", "PARAF_comp_2","peak_C_350.450", "relative_load_comp_1", "relative_load_comp_2",  "Fluorescence_Index", "SUVA254"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_df and add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO",  multi_items("hydro_", 1:2)), #single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("HUMIC",  multi_items("humic_", 1:6)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "F_IONS", "NUTRIENT")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "F_IONS", "HUMIC", "NUTRIENT")),
paths(from = c("HYDRO"), to = c("HUMIC")),
paths(from =c("F_IONS"), to = c("HUMIC")),
paths(from =c("NUTRIENT"), to = c("HUMIC"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nLow flow - Humic")
par(old_par)
```

```{r}

```

## MODEL 7: High flow - streams - Labile 

```{r filtering_06.5, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>%
  filter(format(datetime, "%m-%d") >= "05-01" & format(datetime, "%m-%d") <= "07-31")

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**LABILE:** <br>

```{r runthemodel_09.2, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2", "distance.to.outlet"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating"),
  labile = c("norm_PARAF_c3", "relative_load_comp_3",  "Fluorescence_Index"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO",  multi_items("hydro_", 1:2)), #single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("LABILE",  multi_items("labile_", 1:3)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "F_IONS", "NUTRIENT")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "F_IONS", "LABILE", "NUTRIENT")),
paths(from = c("HYDRO"), to = c("LABILE")),
paths(from =c("F_IONS"), to = c("LABILE")),
paths(from =c("NUTRIENT"), to = c("LABILE"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nHigh flow - Labile")
par(old_par)
```

## MODEL 8: High flow - streams - Labile 

```{r filtering_06.5, include=FALSE}

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )%>% 
  filter((format(datetime, "%m-%d") >= "08-01" & format(datetime, "%m-%d") <= "12-31") | (format(datetime, "%m-%d") >= "01-01" & format(datetime, "%m-%d") <= "04-30"))

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)

**ABOUT THIS MODEL**
- stream samples during peak lower descending to baseflow (August - April 30) n=30
- response is LABILE. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**LABILE:** <br>

```{r runthemodel_09.2, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2", "distance.to.outlet"),
  landcover = c("percent_Beetle.kill", "percent_cut.regenerating"),
  labile = c("norm_PARAF_c3", "relative_load_comp_3",  "Fluorescence_Index"),
  Cfix_ions = c("Mg_mg.l", "Ca_mg.l", "SO4_mg.l"),
  Cgen_nutr = c('NO3_mg.l')
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO",  multi_items("hydro_", 1:2)), #single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("F_IONS", multi_items("Cfix_ions_", 1:3)),
  composite("LABILE",  multi_items("labile_", 1:3)),
  composite("NUTRIENT", multi_items("Cgen_nutr_", 1:1))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "F_IONS", "NUTRIENT")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "F_IONS", "LABILE", "NUTRIENT")),
paths(from = c("HYDRO"), to = c("LABILE")),
paths(from =c("F_IONS"), to = c("LABILE")),
paths(from =c("NUTRIENT"), to = c("LABILE"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the modelâ€™s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r, echo = FALSE}
plot(summary_simple_fef$reliability)
```

```{r, echo = FALSE}
Sys.sleep(1)
```

```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r, echo=FALSE}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  

plot(boot_simple_fef, title = "Bootstrapped Model\nLow flow - Labile")
par(old_par)
```

```{r}

```

