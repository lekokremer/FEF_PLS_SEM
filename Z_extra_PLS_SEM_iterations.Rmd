---
title: "PLS-SEM FEF model exploration and iterations"
author: "Lauren Kremer"
date: "2024-10-27"
output: html_document
---

# Testing iterations of the PLS-SEM FEF model

```{r pkgs, include=FALSE}
# pkgTest is a helper function to load packages and install packages only when they are not installed yet.
pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

#"rstan", "devtools", "tidyverse",  "ggpmisc", "reshape2", 
neededPackages <- c('seminr', 'tidyr', 'dplyr', 'lubridate', 'ggplot2')

for (package in neededPackages){pkgTest(package)}

```


```{r import_data, include = FALSE}
# IMPORT PARAFAC results
# Move up one directory from the current working directory
#file <- normalizePath(file.path(getwd(), "../PARAFAC/df_loadings.csv"))
file <- normalizePath(file.path(getwd(), "datafiles/df_loadings.csv"))
parafac <- read.csv(file, header = TRUE, sep = ",", quote = "\"",
         dec = ".", fill = TRUE) %>%
  # Widen the parafac dataframe
  #pivot_wider(names_from = Component, values_from = Proportion) %>%
  # Extract the sample no. to match other dataframe
  mutate(ID = substr(Sample, nchar(Sample) - 2, nchar(Sample)))
```

```{r import_data2, include = FALSE}

# Move up one directory from the current working directory
file <- normalizePath(file.path(getwd(), "/datafiles/fluoro_vege_manually_corrected_melt.csv"))

# Read the CSV file
sample_vege_fluro_topo <- read.csv(file) 

```

```{r Merge_dataframes, include=FALSE}
# Merge vegetation, topography and fluoro data with PARAFAC results. 
merged_df <- merge(sample_vege_fluro_topo, parafac, by='ID')%>%
  mutate(across(c(watershed, reach, position, TYPE), as.factor))%>%
  mutate(datetime = ymd(date))

merged_df <- merged_df %>%
  mutate(
    percent_Beetle.kill = replace_na(percent_Beetle.kill, 0),
    percent_Old.Forest = replace_na(percent_Old.Forest, 0),
    percent_cut.regenerating = replace_na(percent_cut.regenerating, 0),
    percent_Tundra = replace_na(percent_Tundra, 0),
    percent_Meadows = replace_na(percent_Meadows, 0)
  )
```

```{r Formatting_subsetting, include=FALSE}
# Generate a discharge column that is normalized by the area of the respective watershed.
merged_df<- merged_df%>%
  mutate(Qm3_s = replace_na(Qm3_s, 0.005))

merged_df$discharge_m2 <- merged_df$Qm3_s/merged_df$area_m
merged_df$Input.mm_m2 <- merged_df$Input.mm/merged_df$area_m
merged_df$snowpack_m2 <- merged_df$snowpack_3day_avg/merged_df$area_m

# Transform aspect from degrees to radians
merged_df$aspect_mean_rad <- merged_df$aspect_mean*pi/180

filtered_df <- merged_df %>%
  filter(position == 'stream')%>%
  mutate(
    baseflow = ifelse(stage_num == 1, 1, 0),
    lower_decreasing = ifelse(stage_num == 2, 1, 0),
    upper_decreasing = ifelse(stage_num == 3, 1, 0),
    increasing = ifelse(stage_num == 4, 1, 0)
  )#%>%
  #filter(datetime >= as.POSIXct('2022-06-10 00:10') & datetime <= as.POSIXct('2022-09-15 23:00'))

filtered_df$log_discharge <- log10(filtered_df$Qm3_s) 

filtered_df$log_discharge_m2 <- log10(filtered_df$discharge_m2)  # Adjust constant as needed
filtered_df$log_input_m2 <- log10(filtered_df$Input.mm_m2+ 1e-6)  # Adjust constant as needed

```

For this model demonstration, our EEMs dataset has been filtered to 'stream' samples only (no wells) (n= 91)
The selection process for these variables includes review of the specific response variable, and the correlations of that variable with the explanatory variables found in combine_PARAFAC_w_ws, part 1.B.ii. 

## MODEL 1: Flow state classifier as a latent variable. Total protein-like component  <br>
To include classifications in a PLS model, we generate a column in the dataset for each classificaiton, and a binomial indicators in each row. For example, of the flow state at the time of sampling is just after peak flow, that sample will have a '1' in the upper descending limb column, and a '0' in all others. Potential classifications are 'rising limb', 'upper descending limb', 'lower descending limb' and baseflow. In the path model, lower_decreasing = state_1, upper_decreasing = state_2, increasing = state_3. These classifications were developed by finding the date of peak flow for the respective year and stream, and the dates for the end and beginning of baseflow for each calendar year. Then the 'midway' point between peakflow and the first date of baseflow delineates upper and lower descending limbs. (find the name of this script, pretty sure its an .ipynb)
Build the outer model or 'constructs' or latent variables

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI<br>
**Hydro:**<br>
--log discharge/m2<br>
**DOM:** <br>
-- sample fluorescence of protein-like component 

```{r create_model_df, include=FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),#log_discharge
  #"log_discharge_m2",#"snowpack_3day_avg"#"snowpack_m2"#"log_input_m2", #log_discharge_m2
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  dom = c("PARAF_comp_3"),
  state = c("baseflow", "lower_decreasing", "upper_decreasing", "increasing")
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))
```

```{r, outermodel_1}

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("DOM", single_item('dom_1')),
  composite("STATE", multi_items("state_", 1:4))
)

```

Now for the structural model:

```{r, innermodel_1}
# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "DOM")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "DOM")),
paths(from = c("HYDRO"), to = c("DOM")),
paths(from = c("STATE"), to = c("HYDRO", "DOM"))
)

# Note that neither a dataset nor a measurement model is specified in the structural model state, so we can reuse the structural model object simple_sm across different datasets and measurement models.
```

Model Estimation using the PLS-SEM algorithm. See demo for more info. 

```{r, include=FALSE}
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary <br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.
```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Interpretation:
In this model, we are seeing <br>
-strong, significant relationships between topography and landcover, landcover and discharge (hydro), and flow state (classified by hydrograph limb) and DOM, which is indicated by the total fluorescence of the protein-like component. <br>
- significant but weak relationships between flow state and hydro, and hydro and DOM <br>
- weak and insignificant relationships between
topography and DOM, topography and hydrology, landcover and DOM. <br>
This makes sense. The response variable in this analysis is the total amount of the protein-like component in the sample. We expect this to be positively correlated with the DOM concentration, which typically follows trends similar to flow/runoff. <br>

Let's see if this same model tells a different story if we instead look at the relative fraction of protein in the sample.

## MODEL 2: include a flow state classifier as a latent variable where response is protein-like fraction of DOM.

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI<br>
**Hydro:** <br>
--log discharge/m2 <br>
**DOM:** <br>
-- fraction of protein-like component 

```{r, wholemodel_2, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  dom = c("relative_load_comp_3"),
  state = c("baseflow", "lower_decreasing", "upper_decreasing", "increasing")
)
#"slope_mean",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("DOM", single_item('dom_1')),
  composite("STATE", multi_items("state_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "DOM")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "DOM")),
paths(from = c("HYDRO"), to = c("DOM")),
paths(from = c("STATE"), to = c("HYDRO", "DOM"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, echo = FALSE, warning=FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```

Interpretation:
The response variable changes the details of the model. Now we see that state has little effect on the fraction of protein-like DOM.
We now see a weak but significant influence of both topography and landcover on the protein-like fraction. The relationships among the latent variables (topo-> landcover-> hydrology are similar to those in the previous model.)


## MODEL 3: Remove flow as a latent variable where response is protein-like fraction of DOM. 
Try adding other indicators to hydrology variable 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill<br>
-- mean NDVI <br>
**Hydro:** <br>
--log discharge/m2<br>
**DOM:** <br>
-- fraction of protein-like component 


```{r, wholemodel_3, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2", "Input.mm"),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  dom = c("relative_load_comp_3")
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("DOM", single_item('dom_1'))#,
  #composite("STATE", multi_items("state_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "DOM")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "DOM")),
paths(from = c("HYDRO"), to = c("DOM"))#,
#paths(from = c("STATE"), to = c("HYDRO", "DOM"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Interpretation: In the above workflow, I tried a few combinations of 'hydrological' indicators like input.mm, snowpack.mm, standardized them by watershed area, tried log transformations, (some examples saved in an 'iteration_results.doc in this working directory). Ultimately, the additional indicators did not exhibit sufficent intercorrelation to capture the underlying construct of 'hydrology'. So they do not enchance the latent variables predictive power in relation to DOM, or even the other latent variables.  Therefore, moving forward, the 'hydrology' latent variable will only contain 'discharge' as an indicator. 


## MODEL 4: Remove hydrology altogether as a latent variable where response is protein-like fraction of DOM. 

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill
-- mean NDVI <br>
**DOM:** <br>
-- fraction of protein-like component 


```{r, wholemodel_4, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  #hydro = c("log_discharge_m2", "Input.mm"),#log_discharge
  #"log_discharge_m2",#"snowpack_3day_avg"#"snowpack_m2"#"log_input_m2", #log_discharge_m2
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  dom = c("relative_load_comp_3")
)
#"slope_mean",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  #composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("DOM", single_item('dom_1'))#,
  #composite("STATE", multi_items("state_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("LANDCOVER", "DOM")),
paths(from = c("LANDCOVER"), to = c( "DOM"))#,
#paths(from = c("HYDRO"), to = c("DOM"))#,
#paths(from = c("STATE"), to = c("HYDRO", "DOM"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, include = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Interpretation:
This model proposes that the effect of topography on DOM is indirect, working through landcover changes, without consideration of runoff/discharge. Topographic features influence the type and distribution of landcover, which in turn impacts the fraction of protein-like DOM. This might mean that areas with specific topographic attributes develop landcover that naturally regulates or limits the release of protein-like DOM into the ecosystem. Specifically in this model, topography influences the distribution of beetle kill (2003-2006) affected forests (Tony Vorster's 2017 paper), where drier slopes (southern aspect) were more affected by the outbreak. <br>
After almost 20yrs, we would be expect that many of these killed trees to be some state of decay (advanced? find source) and therefore the breakdown of these complex carbons are now accessible for microbial processing, releasing more labile, protein-like compounds into the watershed. 
So more summarily, topography dictates vegetation patterns, which then influence soil organic matter, microbial activity, and nutrient leaching. It suggests that interventions aiming to influence DOM levels might benefit from managing landcover (at least in our FEF system, though we obviously can't control topography).

Let's look at this model with different landcover types:

## MODEL 5: Change landcover types to harvest regeneration from beetlekill
- response is protein-like fraction of DOM. 


Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**DOM:** <br>
-- fraction of protein-like component of DOM


```{r, wholemodel_5, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  #hydro = c("log_discharge_m2", "Input.mm"),#log_discharge
  #"log_discharge_m2",#"snowpack_3day_avg"#"snowpack_m2"#"log_input_m2", #log_discharge_m2
  landcover = c("percent_cut.regenerating", "ndvi_raster_mean"),
  dom = c("relative_load_comp_3")
)
#"slope_mean",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  #composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("DOM", single_item('dom_1'))#,
  #composite("STATE", multi_items("state_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("LANDCOVER", "DOM")),
paths(from = c("LANDCOVER"), to = c( "DOM"))#,
#paths(from = c("HYDRO"), to = c("DOM"))#,
#paths(from = c("STATE"), to = c("HYDRO", "DOM"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Interpretation:

By replacing beetle kill forest with regenerating harvested forest, we can observe that:<br>
-- The relationship between landcover and DOM becomes weaker and insignificant (β = -0.189). This suggests that, unlike beetle kill areas, regenerating harvested forests do not have a strong influence on the protein-like fraction of DOM.<br>
--The direct path from topography to DOM becomes stronger (β = -0.366) and significant. This indicates that, in the absence of beetle kill forests, topographic factors have a more direct influence on DOM, possibly because they impact soil stability, water flow, or other landscape features that affect DOM transport and accumulation. <br>

This difference could imply that beetle kill forests have a strong influence on the protein-like DOM fraction compared to regenerating forests. Beetle kill areas might themselves be a source of protein-like DOM and/or alter soil and water conditions in ways that change relative component fractions. Regenerating forests, on the other hand, might retain organic material more effectively or simply don’t have the same impact on DOM dynamics as beetle kill areas, likely because of differences in vegetation structure, soil microbial communities, or organic matter decomposition rates.<br>

Maybe Hydrology will have a greater influence on the model if looking at regenerating landcover:

## MODEL 6: Add back hydrology as a latent variable, landcover = regenerating forest

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill
-- mean NDVI<br>
**Hydro:** <br>
--log discharge/m2<br>
--input.mm (snowmelt and precip)<br>
DOM: <br>
-- fraction of protein-like component 


```{r, wholemodel_6, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  hydro = c("log_discharge_m2"),
  landcover = c("percent_cut.regenerating", "ndvi_raster_mean"),
  dom = c("relative_load_comp_3")
)
#"slope_mean",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("HYDRO", single_item("hydro_1")),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("DOM", single_item('dom_1'))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("HYDRO", "LANDCOVER", "DOM")),
paths(from = c("LANDCOVER"), to = c("HYDRO", "DOM")),
paths(from = c("HYDRO"), to = c("DOM"))
)

# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary <br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Interpretation:

So adding the 'hydro' latent variable in a circumstance where landcover does not strongly influence DOM does not add any explanatory power to the model. 

Let's remove hydro again and explore how these dynamics change if our response is a humic-like fraction instead of protein-like. 

## MODEL 7: Change response to fraction of humic DOM
keeping regeneration forest for now, removing 'hydro' as a latent variable

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with harvested/regenerating vegetation
-- mean NDVI <br>
**DOM:** <br>
-- fraction of humic component 1


```{r, wholemodel_7, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  landcover = c("percent_cut.regenerating", "ndvi_raster_mean"),
  dom = c("relative_load_comp_1")
)
#"slope_mean",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  #composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("DOM", single_item('dom_1'))#,
  #composite("STATE", multi_items("state_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("LANDCOVER", "DOM")),
paths(from = c("LANDCOVER"), to = c( "DOM"))#,
#paths(from = c("HYDRO"), to = c("DOM"))#,
#paths(from = c("STATE"), to = c("HYDRO", "DOM"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.
```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Interpretation:
Changing the response does not significantly change the model from model 5. 

Let's try a beetle kill model with this same response to see if our interpretation of model 5 changes: 


## MODEL 8: Change response to fraction of humic DOM with Beetlekill %

Our indicators for each latent variable are as follows:<br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel<br>
--mean aspect in radians<br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with >50% beetlekill
-- mean NDVI <br>
**DOM:** <br>
-- fraction of humic component 1


```{r, wholemodel_8, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  landcover = c("percent_Beetle.kill", "ndvi_raster_mean"),
  dom = c("relative_load_comp_1")
)

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  composite("LANDCOVER", multi_items("landcover_", 1:2)),
  composite("DOM", single_item('dom_1'))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("LANDCOVER", "DOM")),
paths(from = c("LANDCOVER"), to = c( "DOM"))
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.
```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  


plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)

```

Interpretation: This model is similar to model 4, proposes that the effect of topography on DOM is indirect, working through landcover changes. Topographic features influence the type and distribution of landcover, which in turn impacts the fraction of protein-like DOM. The direction of the influence on humic DOC is opposite of that on the protein-like component. 

## MODEL 9: Tundra influence on change to fraction of humic DOM

Our indicators for each latent variable are as follows: <br>
**Topo:** <br>
--mean distance that allochthonous water has to travel to the stream channel <br>
--mean aspect in radians <br>
--mean subcatchment TWI <br>
**Landcover:** <br>
-- % of subcatchment pixels with Tundra
-- mean NDVI <br>
**DOM:** <br>
-- fraction of protein-like component 3

```{r, wholemodel_9, include = FALSE}
# Initialize model_df with the same number of rows as merged_df
model_df <- data.frame(matrix(ncol = 0, nrow = nrow(filtered_df)))

# Define a list of constructs and their corresponding variables
indicators <- list(
  topo = c( "disttostreams_mean", "aspect_mean_rad", 'twi_mean'),
  landcover = c("percent_Old.Forest", "ndvi_raster_mean", "percent_.15", "percent_11.15"),#"percent_Tundra", 
  #hydro = c("log_discharge_m2"),
  dom = c("relative_load_comp_3")
)
#"slope_mean",

# Loop through each indicator and rename columns
for (indicator in names(indicators)) {
  variables <- indicators[[indicator]]
  for (i in seq_along(variables)) {
    old_name <- variables[i]
    new_name <- paste0(indicator, "_", i)
    
    # Check if the old name exists in filtered_dfand add it to model_df with the new name
    if (old_name %in% colnames(filtered_df)) {
      model_df[[new_name]] <- filtered_df[[old_name]]
    } else {
      warning(paste("Column", old_name, "not found in filtered_df"))
    }
  }
}

# Check the new column names in model_df
colnames(model_df)

# Standardizing the environmental variables
model_df_standardized <- as.data.frame(scale(model_df, center = TRUE, scale = TRUE))

simple_FEF_mm <- constructs(
  composite("TOPO", multi_items("topo_", 1:3)),
  #composite("HYDRO", single_item("hydro_1")),# multi_items("hydro_", 1:2)),, 
  composite("LANDCOVER", multi_items("landcover_", 1:4)),
  composite("DOM", single_item('dom_1'))#,
  #composite("STATE", multi_items("state_", 1:4))
)

# Create structural model
simple_FEF_sm <- relationships(
paths(from = c("TOPO"), to = c("LANDCOVER", "DOM")), #"HYDRO", 
#paths(from = c("HYDRO"), to = c("DOM")),
paths(from = c("LANDCOVER"), to = c( "DOM")) #"HYDRO",
)
# Estimate the model
fef_simple_model <- estimate_pls(data = model_df_standardized,
measurement_model = simple_FEF_mm,
structural_model = simple_FEF_sm,
inner_weights = path_weighting,
missing = mean_replacement,
missing_value = "NA")
```

Output summary<br>
Recall that path coefficients indicate the relationship between the two latent variables and we generally want reliability indicators to be high. e.g., rhoC represents internal consistency reliability, which is the extent to which indicators measuring the same construct are associated with each other. values over 0.95 can indicate redundancy, but values over 0.7 are preferred.

```{r, echo = FALSE}
# Summarize the model results
summary_simple_fef <- summary(fef_simple_model)

# Inspect the model’s path coefficients and the R^2 values
print(summary_simple_fef)
```

A plot of result reliability measures:
```{r}
plot(summary_simple_fef$reliability)
```


```{r, include=FALSE}
# Bootstrap the model
boot_simple_fef <- bootstrap_model(seminr_model = fef_simple_model,
nboot = 500,
cores = NULL,
seed = 123)
# Store the summary of the bootstrapped model
sum_boot_simple_fef <- summary(boot_simple_fef)
```

### Results of bootstrapped PLS

```{r}
# Extract the bootstrapped HTMT
sum_boot_fef <- summary(boot_simple_fef, alpha= 0.10)

sum_boot_fef$bootstrapped_HTMT
```

This gives us the confidence intervals of the HTMT ratio.

```{r, include=FALSE}
# Inspect the bootstrapped structural paths
sum_boot_simple_fef$bootstrapped_paths
# Inspect the bootstrapped indicator loadings
sum_boot_simple_fef$bootstrapped_loadings
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=4}
# generate a small model for creating the plot
# recall that constructs are stored in simple_FEF_mm
# and the structural model is stored in simple_FEF_sm
# and the model estimation is in fef_simple_model

# bootstrap results in boot_simple_fef
# Save the original graphical parameters
old_par <- par()  

# Change 'cex' for larger text size
par(cex = 0.5)  
plot(boot_simple_fef, title = "Bootstrapped Model")
par(old_par)
```

Interpretation: 
Tundra has little influence on DOM when it is characterized by the fraction of the protein-like component, 

# Grouping response variables 
Rather than generating a single latent variable 'DOM', it may be useful to structure the model responses as as latent variables that contain multiple indicators, like groupings of component fractions, total component loading normalized by DOC, Fluorescence indices, and BOD output.  From this I might be able to determine what variables are influencing humic input, relative to those that drive lability. 






# Reporting initial results and evaluating the quality of our favorite model

1. Indicator reliability:
First we want to know how much of each indicator's variance is explained by the latent variable it is assigned to. 
The indicator loading is like a score showing how closely that piece of information is related to the concept it measures. It’s a number between 0 and 1, with numbers closer to 1 meaning a stronger connection. This tells us how much of the information (or variation) in the indicator is explained by the concept it is measuring.
To find this, we take the indicator loading and square it. For example, if the indicator loading is 0.8, squaring it (0.8 × 0.8) gives 0.64, or 64%. This means 64% of the information in that indicator is explained by the concept it measures.
'Indicator loadings above 0.708 are recommended, since they indicate that the construct explains more than 50 percent of the indicator’s variance, thus providing acceptable indicator reliability.' Hair et al. 2021

```{r, echo=FALSE}
#Inspect the indicator reliability
summary_simple_fef$loadings^2
```

Take home: Our current topo_3 (subwatershed area in m^2) as a low reliability which can contribute to more measurement error to the model, which can weaken the model’s validity and interpretability. This means that less than 50% of it's variance is explained by other 'topography' indicators, which makes sense. This may be a better variable to group with 'hydrology'. 

2. Then we want to check the 'internal consistency reliability' (rhoC). Internal consistency reliability is the extent to which indicators measuring the same construct are associated with each other.
'Higher values indicate higher levels of reliability. For example, reliability values between 0.60 and 0.70 are considered “acceptable in exploratory research,” whereas values between 0.70 and 0.90 range from “satisfactory to good.” Values above 0.90 (and definitely above 0.95) are problematic, since they indicate that the indicators are redundant, thereby reducing construct validity (Diamantopoulos, Sarstedt, Fuchs, Wilczynski, & Kaiser, 2012).'Hair et al. 2021  Other sources indicate that 0.85 is a more conservative threshold value. 

```{r, echo=FALSE}
print(summary_simple_fef$reliability)
```

Our rhoC values fall in the higher (not ideal) range of 'satisfactory to good' but our 'problematic' values are likely due to these latent values having single indicators. 

3. Convergent Validity
When we assess convergent validity, we're checking how well each indicator represents the latent variable it's supposed to measure. For convergent validity, we want to see if the indicators of the same latent variable are closely related. This is where average variance extracted (AVE) comes in:

- AVE shows how much of the total variance in the indicators is actually explained by the construct.

```{r, include=FALSE}
print(summary_simple_fef$reliability)
```

Here then we should not be surprised to see 1.00 for HYDRO and DOM AVE, as, up to this point, we have included only one indicator for these latent variables. However, for topo and landcover, we can be confident that we have chosen variables that are measuring the same thing as our AVE are high (over 0.5)

4. Discriminant Validity
Now we want to make sure that different latent variables in the model are distinct from each other, ie. they measure different concepts. One way to check this is by using the heterotrait–monotrait (HTMT) ratio.

If the HTMT values are low (typically below 0.9), it indicates that the constructs are distinct and measure different concepts.


```{r, include=FALSE}
print(summary_simple_fef$validity$htmt)
```

Interpretation: In this current model configuration, topo and landcover may not be distinct. This is hardly surprising, landcover is directly correlated with many of the topographical variables. In this case, we are looking at the percentage of each subwatershed that is covered by 'cut/regenerating' forest. Many of these sites were on lower slopes (likely for ease of access), and in the case of Deadhorse, almost entirely on the southern aspect. Furthermore, 'TWI' or the total wetness index likely drives NDVI. A high correlation between topography and landcover in our SEM model isn't necessarily problematic if it aligns with the underlying ecology of the study area
Combining them into a single latent variable isn't ideal for our research question, where we want to see if we can evaluate the impacts of land cover independent of topography. We may not have this issue if we look at other land cover types. Let's come back to this to see if it needs addressing. We might be able to control for one construct in relation to the other, such as controlling for topography when examining landcover’s effect, to clarify their roles without removing one or the other. 


```{r}

```







